
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>blocowallet: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">blocowallet/cmd/blocowallet/main.go (0.0%)</option>
				
				<option value="file1">blocowallet/internal/blockchain/chainlist.go (0.0%)</option>
				
				<option value="file2">blocowallet/internal/blockchain/ethereum.go (0.0%)</option>
				
				<option value="file3">blocowallet/internal/blockchain/multi_provider.go (0.0%)</option>
				
				<option value="file4">blocowallet/internal/storage/sqlite.go (74.4%)</option>
				
				<option value="file5">blocowallet/internal/ui/commands.go (0.0%)</option>
				
				<option value="file6">blocowallet/internal/ui/delete_dialog.go (0.0%)</option>
				
				<option value="file7">blocowallet/internal/ui/handlers.go (0.0%)</option>
				
				<option value="file8">blocowallet/internal/ui/network_operations.go (17.9%)</option>
				
				<option value="file9">blocowallet/internal/ui/settings_views.go (0.0%)</option>
				
				<option value="file10">blocowallet/internal/ui/tui.go (0.0%)</option>
				
				<option value="file11">blocowallet/internal/ui/wallet_operations.go (32.9%)</option>
				
				<option value="file12">blocowallet/internal/wallet/crypto.go (95.0%)</option>
				
				<option value="file13">blocowallet/internal/wallet/service.go (55.5%)</option>
				
				<option value="file14">blocowallet/internal/wallet/wallet.go (72.7%)</option>
				
				<option value="file15">blocowallet/pkg/config/config.go (15.8%)</option>
				
				<option value="file16">blocowallet/pkg/logger/logger.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"
        "os"
        "path/filepath"

        "blocowallet/internal/blockchain"
        "blocowallet/internal/storage"
        "blocowallet/internal/ui"
        "blocowallet/internal/wallet"
        "blocowallet/pkg/config"

        tea "github.com/charmbracelet/bubbletea"
)

func main() <span class="cov0" title="0">{
        // Setup application directory
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to get user home directory: %v", err)
        }</span>

        <span class="cov0" title="0">appDir := filepath.Join(homeDir, ".blocowallet")
        if err := os.MkdirAll(appDir, 0755); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create app directory: %v", err)
        }</span>

        // Load configuration
        <span class="cov0" title="0">cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load config: %v", err)
        }</span>

        // Initialize storage
        <span class="cov0" title="0">dbPath := cfg.Database.Path
        if dbPath == "" || dbPath == "wallets.db" || !filepath.IsAbs(dbPath) </span><span class="cov0" title="0">{
                dbPath = filepath.Join(appDir, "wallets.db")
        }</span>

        // Ensure the directory for the database exists
        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(dbPath), 0755); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create database directory: %v", err)
        }</span>

        <span class="cov0" title="0">repo, err := storage.NewSQLite(dbPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize storage: %v", err)
        }</span>
        <span class="cov0" title="0">defer repo.Close()

        // Initialize multi provider for all active networks
        multiProvider := blockchain.NewMultiProvider()
        defer multiProvider.Close()

        // Setup providers for all networks
        multiProvider.RefreshProviders(cfg)

        // Initialize wallet service with multi-provider
        walletService := wallet.NewServiceWithMultiProvider(repo, multiProvider)

        // Initialize and run TUI
        model := ui.NewModel(walletService, cfg)
        p := tea.NewProgram(model, tea.WithAltScreen())

        if _, err := p.Run(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to run TUI: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package blockchain

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strconv"
        "strings"
        "sync"
        "time"
)

// RPCEndpoint represents an RPC endpoint from ChainList API
type RPCEndpoint struct {
        URL          string `json:"url"`
        Tracking     string `json:"tracking"`
        IsOpenSource bool   `json:"isOpenSource"`
}

// ChainInfo represents chain information from ChainList API
type ChainInfo struct {
        ChainID        int    `json:"chainId"`
        Name           string `json:"name"`
        NativeCurrency struct {
                Name     string `json:"name"`
                Symbol   string `json:"symbol"`
                Decimals int    `json:"decimals"`
        } `json:"nativeCurrency"`
        RPC       []RPCEndpoint `json:"rpc"`
        Explorers []struct {
                Name string `json:"name"`
                URL  string `json:"url"`
        } `json:"explorers"`
}

// ChainListService handles interaction with ChainList API
type ChainListService struct {
        client      *http.Client
        baseURL     string
        chains      []ChainInfo
        cacheMu     sync.RWMutex
        cacheExpiry time.Time
}

// NetworkSuggestion represents a search suggestion for a network
type NetworkSuggestion struct {
        ChainID int    `json:"chainId"`
        Name    string `json:"name"`
        Symbol  string `json:"symbol"`
}

// RPCConnectionResult represents the result of testing an RPC connection
type RPCConnectionResult struct {
        URL     string
        Success bool
        Error   error
        ChainID int
        Latency time.Duration
}

// NewChainListService creates a new ChainList service
func NewChainListService() *ChainListService <span class="cov0" title="0">{
        return &amp;ChainListService{
                client: &amp;http.Client{
                        Timeout: 10 * time.Second,
                },
                baseURL: "https://chainlist.org",
                chains:  make([]ChainInfo, 0),
        }
}</span>

// GetChainInfo fetches chain information by chain ID
func (s *ChainListService) GetChainInfo(chainID int) (*ChainInfo, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rpcs.json", s.baseURL)

        resp, err := s.client.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch chain list: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API request failed with status: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %w", err)
        }</span>

        <span class="cov0" title="0">var chains []ChainInfo
        if err := json.Unmarshal(body, &amp;chains); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse JSON response: %w", err)
        }</span>

        // Find chain by ID
        <span class="cov0" title="0">for _, chain := range chains </span><span class="cov0" title="0">{
                if chain.ChainID == chainID </span><span class="cov0" title="0">{
                        return &amp;chain, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("chain with ID %d not found", chainID)</span>
}

// ValidateRPCEndpoint checks if an RPC endpoint is accessible
func (s *ChainListService) ValidateRPCEndpoint(rpcURL string) error <span class="cov0" title="0">{
        if rpcURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("RPC URL cannot be empty")
        }</span>

        // Create a simple JSON-RPC request to check if the endpoint is alive
        <span class="cov0" title="0">reqBody := `{"jsonrpc":"2.0","method":"eth_chainId","params":[],"id":1}`

        resp, err := s.client.Post(rpcURL, "application/json",
                strings.NewReader(reqBody))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("RPC endpoint is not accessible: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("RPC endpoint returned status: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetChainIDFromRPC attempts to get chain ID from RPC endpoint
func (s *ChainListService) GetChainIDFromRPC(rpcURL string) (int, error) <span class="cov0" title="0">{
        reqBody := `{"jsonrpc":"2.0","method":"eth_chainId","params":[],"id":1}`

        resp, err := s.client.Post(rpcURL, "application/json",
                strings.NewReader(reqBody))
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to call RPC: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("RPC call failed with status: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var result struct {
                Result string `json:"result"`
                Error  *struct {
                        Code    int    `json:"code"`
                        Message string `json:"message"`
                } `json:"error"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">if result.Error != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("RPC error: %s", result.Error.Message)
        }</span>

        // Convert hex chain ID to int
        <span class="cov0" title="0">chainID, err := strconv.ParseInt(result.Result, 0, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse chain ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(chainID), nil</span>
}

// loadChains loads and caches chain data from ChainList API
func (s *ChainListService) loadChains() error <span class="cov0" title="0">{
        s.cacheMu.Lock()
        defer s.cacheMu.Unlock()

        // Check if cache is still valid (24 hours)
        if time.Now().Before(s.cacheExpiry) &amp;&amp; len(s.chains) &gt; 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("%s/rpcs.json", s.baseURL)
        resp, err := s.client.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to fetch chain list: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("API request failed with status: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read response body: %w", err)
        }</span>

        <span class="cov0" title="0">var chains []ChainInfo
        if err := json.Unmarshal(body, &amp;chains); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse JSON response: %w", err)
        }</span>

        <span class="cov0" title="0">s.chains = chains
        s.cacheExpiry = time.Now().Add(24 * time.Hour)
        return nil</span>
}

// SearchNetworksByName searches for networks by name with fuzzy matching
func (s *ChainListService) SearchNetworksByName(query string) ([]NetworkSuggestion, error) <span class="cov0" title="0">{
        if err := s.loadChains(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">s.cacheMu.RLock()
        defer s.cacheMu.RUnlock()

        query = strings.ToLower(strings.TrimSpace(query))
        if query == "" </span><span class="cov0" title="0">{
                return []NetworkSuggestion{}, nil
        }</span>

        <span class="cov0" title="0">var suggestions []NetworkSuggestion
        for _, chain := range s.chains </span><span class="cov0" title="0">{
                name := strings.ToLower(chain.Name)

                // Exact match gets priority
                if name == query </span><span class="cov0" title="0">{
                        suggestions = append([]NetworkSuggestion{{
                                ChainID: chain.ChainID,
                                Name:    chain.Name,
                                Symbol:  chain.NativeCurrency.Symbol,
                        }}, suggestions...)
                        continue</span>
                }

                // Contains match
                <span class="cov0" title="0">if strings.Contains(name, query) </span><span class="cov0" title="0">{
                        suggestions = append(suggestions, NetworkSuggestion{
                                ChainID: chain.ChainID,
                                Name:    chain.Name,
                                Symbol:  chain.NativeCurrency.Symbol,
                        })
                }</span>
        }

        // Limit results to avoid overwhelming the UI
        <span class="cov0" title="0">if len(suggestions) &gt; 10 </span><span class="cov0" title="0">{
                suggestions = suggestions[:10]
        }</span>

        <span class="cov0" title="0">return suggestions, nil</span>
}

// GetChainInfoWithRetry gets chain info and tests RPC endpoints with retry logic
func (s *ChainListService) GetChainInfoWithRetry(chainID int) (*ChainInfo, string, error) <span class="cov0" title="0">{
        if err := s.loadChains(); err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">s.cacheMu.RLock()
        chains := s.chains
        s.cacheMu.RUnlock()

        // Find chain by ID
        var targetChain *ChainInfo
        for _, chain := range chains </span><span class="cov0" title="0">{
                if chain.ChainID == chainID </span><span class="cov0" title="0">{
                        targetChain = &amp;chain
                        break</span>
                }
        }

        <span class="cov0" title="0">if targetChain == nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("chain with ID %d not found", chainID)
        }</span>

        // Test RPC endpoints and find the best one
        <span class="cov0" title="0">workingRPC, err := s.findBestRPCEndpoint(targetChain.RPC, chainID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("no working RPC endpoint found: %w", err)
        }</span>

        <span class="cov0" title="0">return targetChain, workingRPC, nil</span>
}

// findBestRPCEndpoint tests all RPC endpoints and returns the fastest working one
func (s *ChainListService) findBestRPCEndpoint(endpoints []RPCEndpoint, expectedChainID int) (string, error) <span class="cov0" title="0">{
        if len(endpoints) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no RPC endpoints available")
        }</span>

        // Channel to collect results
        <span class="cov0" title="0">results := make(chan RPCConnectionResult, len(endpoints))

        // Test all endpoints concurrently
        for _, endpoint := range endpoints </span><span class="cov0" title="0">{
                go func(ep RPCEndpoint) </span><span class="cov0" title="0">{
                        result := RPCConnectionResult{URL: ep.URL}
                        start := time.Now()

                        chainID, err := s.testRPCEndpoint(ep.URL, expectedChainID)
                        result.Latency = time.Since(start)

                        if err != nil </span><span class="cov0" title="0">{
                                result.Success = false
                                result.Error = err
                        }</span> else<span class="cov0" title="0"> {
                                result.Success = true
                                result.ChainID = chainID
                        }</span>

                        <span class="cov0" title="0">results &lt;- result</span>
                }(endpoint)
        }

        // Collect results and find the best one
        <span class="cov0" title="0">var bestResult *RPCConnectionResult

        for i := 0; i &lt; len(endpoints); i++ </span><span class="cov0" title="0">{
                result := &lt;-results
                if result.Success &amp;&amp; result.ChainID == expectedChainID </span><span class="cov0" title="0">{
                        // Select the fastest endpoint
                        if bestResult == nil || result.Latency &lt; bestResult.Latency </span><span class="cov0" title="0">{
                                bestResult = &amp;result
                        }</span>
                }
        }

        <span class="cov0" title="0">if bestResult == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no working RPC endpoints found for chain ID %d", expectedChainID)
        }</span>

        <span class="cov0" title="0">return bestResult.URL, nil</span>
}

// testRPCEndpoint tests a single RPC endpoint
func (s *ChainListService) testRPCEndpoint(rpcURL string, expectedChainID int) (int, error) <span class="cov0" title="0">{
        if rpcURL == "" || !strings.HasPrefix(rpcURL, "http") </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid RPC URL")
        }</span>

        // Create a client with shorter timeout for testing
        <span class="cov0" title="0">client := &amp;http.Client{Timeout: 5 * time.Second}

        reqBody := `{"jsonrpc":"2.0","method":"eth_chainId","params":[],"id":1}`
        resp, err := client.Post(rpcURL, "application/json", strings.NewReader(reqBody))
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("RPC request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("RPC returned status: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var result struct {
                Result string `json:"result"`
                Error  *struct {
                        Code    int    `json:"code"`
                        Message string `json:"message"`
                } `json:"error"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">if result.Error != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("RPC error: %s", result.Error.Message)
        }</span>

        // Convert hex chain ID to int
        <span class="cov0" title="0">chainID, err := strconv.ParseInt(result.Result, 0, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse chain ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(chainID), nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package blockchain

import (
        "context"
        "fmt"
        "math/big"
        "time"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/ethclient"
)

// Ethereum implements wallet.BalanceProvider for Ethereum blockchain
type Ethereum struct {
        client    *ethclient.Client
        timeout   time.Duration
        symbol    string
        decimals  int
        chainName string
}

// NewEthereum creates a new Ethereum balance provider
func NewEthereum(rpcURL string, timeout time.Duration, symbol string, decimals int, chainName string) (*Ethereum, error) <span class="cov0" title="0">{
        client, err := ethclient.Dial(rpcURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to Ethereum node: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Ethereum{
                client:    client,
                timeout:   timeout,
                symbol:    symbol,
                decimals:  decimals,
                chainName: chainName,
        }, nil</span>
}

// GetBalance gets the ETH balance for an address
func (e *Ethereum) GetBalance(ctx context.Context, address string) (*big.Int, error) <span class="cov0" title="0">{
        // Add timeout to context
        ctx, cancel := context.WithTimeout(ctx, e.timeout)
        defer cancel()

        if !common.IsHexAddress(address) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid Ethereum address: %s", address)
        }</span>

        <span class="cov0" title="0">addr := common.HexToAddress(address)
        balance, err := e.client.BalanceAt(ctx, addr, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get balance for address %s: %w", address, err)
        }</span>

        <span class="cov0" title="0">return balance, nil</span>
}

// Close closes the Ethereum client connection
func (e *Ethereum) Close() <span class="cov0" title="0">{
        e.client.Close()
}</span>

// GetNetworkSymbol returns the symbol of the network (ETH, MATIC, etc)
func (e *Ethereum) GetNetworkSymbol() string <span class="cov0" title="0">{
        return e.symbol
}</span>

// GetNetworkDecimals returns the number of decimals for the network's native currency
func (e *Ethereum) GetNetworkDecimals() int <span class="cov0" title="0">{
        return e.decimals
}</span>

// GetChainName returns the name of the blockchain
func (e *Ethereum) GetChainName() string <span class="cov0" title="0">{
        return e.chainName
}</span>

// Mock implementation for testing/development
type Mock struct {
        symbol   string
        decimals int
}

// NewMock creates a new mock balance provider
func NewMock() *Mock <span class="cov0" title="0">{
        return &amp;Mock{
                symbol:   "ETH",
                decimals: 18,
        }
}</span>

// GetBalance returns a mock balance
func (m *Mock) GetBalance(ctx context.Context, address string) (*big.Int, error) <span class="cov0" title="0">{
        // Return a mock balance of 1.5 ETH (1.5 * 10^18 wei)
        balance := new(big.Int)
        balance.SetString("1500000000000000000", 10)
        return balance, nil
}</span>

// GetNetworkSymbol returns the symbol of the network (ETH, MATIC, etc)
func (m *Mock) GetNetworkSymbol() string <span class="cov0" title="0">{
        return m.symbol
}</span>

// GetNetworkDecimals returns the number of decimals for the network's native currency
func (m *Mock) GetNetworkDecimals() int <span class="cov0" title="0">{
        return m.decimals
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package blockchain

import (
        "context"
        "fmt"
        "math/big"
        "sync"
        "time"

        "blocowallet/pkg/config"
)

// MultiProvider manages multiple balance providers for different networks
type MultiProvider struct {
        providers map[string]Provider
        networks  map[string]config.Network
        mu        sync.RWMutex
}

// Provider represents a blockchain provider with network information
type Provider struct {
        balanceProvider BalanceProvider
        network         config.Network
}

// BalanceProvider is interface implemented by Ethereum, Mock, etc.
type BalanceProvider interface {
        GetBalance(ctx context.Context, address string) (*big.Int, error)
        GetNetworkSymbol() string
        GetNetworkDecimals() int
}

// NewMultiProvider creates a new MultiProvider
func NewMultiProvider() *MultiProvider <span class="cov0" title="0">{
        return &amp;MultiProvider{
                providers: make(map[string]Provider),
                networks:  make(map[string]config.Network),
        }
}</span>

// AddProvider adds a balance provider for a specific network
func (mp *MultiProvider) AddProvider(key string, provider BalanceProvider, network config.Network) <span class="cov0" title="0">{
        mp.mu.Lock()
        defer mp.mu.Unlock()

        mp.providers[key] = Provider{
                balanceProvider: provider,
                network:         network,
        }
        mp.networks[key] = network
}</span>

// RemoveProvider removes a balance provider for a specific network
func (mp *MultiProvider) RemoveProvider(key string) <span class="cov0" title="0">{
        mp.mu.Lock()
        defer mp.mu.Unlock()

        if provider, exists := mp.providers[key]; exists </span><span class="cov0" title="0">{
                // If the provider implements Close method, call it
                if closer, ok := provider.balanceProvider.(interface{ Close() }); ok </span><span class="cov0" title="0">{
                        closer.Close()
                }</span>
                <span class="cov0" title="0">delete(mp.providers, key)
                delete(mp.networks, key)</span>
        }
}

// GetBalance gets the balance for a wallet on all active networks
type NetworkBalance struct {
        NetworkKey  string
        NetworkName string
        Symbol      string
        Decimals    int
        Amount      *big.Int
        Error       error
}

// GetAllBalances gets the balance for a wallet address on all active networks
func (mp *MultiProvider) GetAllBalances(ctx context.Context, address string) []NetworkBalance <span class="cov0" title="0">{
        mp.mu.RLock()
        defer mp.mu.RUnlock()

        results := make([]NetworkBalance, 0, len(mp.providers))

        // For each provider, get the balance
        for key, provider := range mp.providers </span><span class="cov0" title="0">{
                if !provider.network.IsActive </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">balance := NetworkBalance{
                        NetworkKey:  key,
                        NetworkName: provider.network.Name,
                        Symbol:      provider.balanceProvider.GetNetworkSymbol(),
                        Decimals:    provider.balanceProvider.GetNetworkDecimals(),
                }

                amount, err := provider.balanceProvider.GetBalance(ctx, address)
                if err != nil </span><span class="cov0" title="0">{
                        balance.Error = fmt.Errorf("failed to get balance on %s: %w", provider.network.Name, err)
                }</span> else<span class="cov0" title="0"> {
                        balance.Amount = amount
                }</span>

                <span class="cov0" title="0">results = append(results, balance)</span>
        }

        <span class="cov0" title="0">return results</span>
}

// RefreshProviders updates the provider list based on current network configuration
func (mp *MultiProvider) RefreshProviders(cfg *config.Config) <span class="cov0" title="0">{
        mp.mu.Lock()
        defer mp.mu.Unlock()

        // Track which networks we still need
        stillNeeded := make(map[string]bool)

        // First handle default networks
        for key, network := range cfg.Networks </span><span class="cov0" title="0">{
                stillNeeded[key] = true

                // Skip inactive networks
                if !network.IsActive </span><span class="cov0" title="0">{
                        continue</span>
                }

                // If we already have this provider, continue
                <span class="cov0" title="0">if _, exists := mp.providers[key]; exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Create a new provider
                <span class="cov0" title="0">if network.RPCEndpoint != "" </span><span class="cov0" title="0">{
                        provider, err := NewEthereum(
                                network.RPCEndpoint,
                                DefaultTimeout,
                                network.Symbol,
                                18, // Most EVM chains use 18 decimals
                                network.Name,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                // If we can't connect, use a mock provider
                                mockProvider := NewMock()
                                mp.providers[key] = Provider{
                                        balanceProvider: mockProvider,
                                        network:         network,
                                }
                        }</span> else<span class="cov0" title="0"> {
                                mp.providers[key] = Provider{
                                        balanceProvider: provider,
                                        network:         network,
                                }
                        }</span>
                        <span class="cov0" title="0">mp.networks[key] = network</span>
                }
        }

        // Then handle custom networks
        <span class="cov0" title="0">for key, network := range cfg.CustomNetworks </span><span class="cov0" title="0">{
                stillNeeded[key] = true

                // Skip inactive networks
                if !network.IsActive </span><span class="cov0" title="0">{
                        continue</span>
                }

                // If we already have this provider, continue
                <span class="cov0" title="0">if _, exists := mp.providers[key]; exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Create a new provider
                <span class="cov0" title="0">if network.RPCEndpoint != "" </span><span class="cov0" title="0">{
                        provider, err := NewEthereum(
                                network.RPCEndpoint,
                                DefaultTimeout,
                                network.Symbol,
                                18, // Most EVM chains use 18 decimals
                                network.Name,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                // If we can't connect, use a mock provider
                                mockProvider := NewMock()
                                mp.providers[key] = Provider{
                                        balanceProvider: mockProvider,
                                        network:         network,
                                }
                        }</span> else<span class="cov0" title="0"> {
                                mp.providers[key] = Provider{
                                        balanceProvider: provider,
                                        network:         network,
                                }
                        }</span>
                        <span class="cov0" title="0">mp.networks[key] = network</span>
                }
        }

        // Remove providers for networks that no longer exist or are inactive
        <span class="cov0" title="0">for key, provider := range mp.providers </span><span class="cov0" title="0">{
                if needed, exists := stillNeeded[key]; !exists || !needed </span><span class="cov0" title="0">{
                        // Remove provider if network no longer exists
                        if closer, ok := provider.balanceProvider.(interface{ Close() }); ok </span><span class="cov0" title="0">{
                                closer.Close()
                        }</span>
                        <span class="cov0" title="0">delete(mp.providers, key)
                        delete(mp.networks, key)</span>
                } else<span class="cov0" title="0"> {
                        // Update network status in cached networks
                        if network, exists := cfg.Networks[key]; exists </span><span class="cov0" title="0">{
                                mp.networks[key] = network
                        }</span> else<span class="cov0" title="0"> if network, exists := cfg.CustomNetworks[key]; exists </span><span class="cov0" title="0">{
                                mp.networks[key] = network
                        }</span>
                }
        }
}

// Default timeout for blockchain connections
const DefaultTimeout = 30 * time.Second

// Close closes all providers
func (mp *MultiProvider) Close() <span class="cov0" title="0">{
        mp.mu.Lock()
        defer mp.mu.Unlock()

        for key, provider := range mp.providers </span><span class="cov0" title="0">{
                // If the provider implements Close method, call it
                if closer, ok := provider.balanceProvider.(interface{ Close() }); ok </span><span class="cov0" title="0">{
                        closer.Close()
                }</span>
                <span class="cov0" title="0">delete(mp.providers, key)</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package storage

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "blocowallet/internal/wallet"

        _ "github.com/mattn/go-sqlite3"
)

// SQLite implements wallet.Repository using SQLite
type SQLite struct {
        db *sql.DB
}

// NewSQLite creates a new SQLite repository
func NewSQLite(databasePath string) (*SQLite, error) <span class="cov8" title="1">{
        db, err := sql.Open("sqlite3", databasePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        <span class="cov8" title="1">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov8" title="1">sqlite := &amp;SQLite{db: db}

        if err := sqlite.createTables(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create tables: %w", err)
        }</span>

        <span class="cov8" title="1">return sqlite, nil</span>
}

// createTables creates the necessary database tables
func (s *SQLite) createTables() error <span class="cov8" title="1">{
        query := `
        CREATE TABLE IF NOT EXISTS wallets (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                address TEXT UNIQUE NOT NULL,
                keystore_path TEXT NOT NULL,
                encrypted_mnemonic TEXT,
                created_at DATETIME NOT NULL,
                updated_at DATETIME NOT NULL
        );
        `

        _, err := s.db.Exec(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create wallets table: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Create creates a new wallet in the database
func (s *SQLite) Create(ctx context.Context, w *wallet.Wallet) error <span class="cov8" title="1">{
        query := `
        INSERT INTO wallets (id, name, address, keystore_path, encrypted_mnemonic, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        _, err := s.db.ExecContext(ctx, query,
                w.ID, w.Name, w.Address, w.KeyStorePath, w.EncryptedMnemonic, w.CreatedAt, w.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create wallet: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetByID retrieves a wallet by ID
func (s *SQLite) GetByID(ctx context.Context, id string) (*wallet.Wallet, error) <span class="cov8" title="1">{
        query := `
        SELECT id, name, address, keystore_path, encrypted_mnemonic, created_at, updated_at
        FROM wallets WHERE id = ?
        `

        row := s.db.QueryRowContext(ctx, query, id)

        var w wallet.Wallet
        var createdAt, updatedAt string

        err := row.Scan(&amp;w.ID, &amp;w.Name, &amp;w.Address, &amp;w.KeyStorePath, &amp;w.EncryptedMnemonic, &amp;createdAt, &amp;updatedAt)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("wallet not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to scan wallet: %w", err)</span>
        }

        <span class="cov8" title="1">if w.CreatedAt, err = time.Parse(time.RFC3339, createdAt); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse created_at: %w", err)
        }</span>

        <span class="cov8" title="1">if w.UpdatedAt, err = time.Parse(time.RFC3339, updatedAt); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse updated_at: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;w, nil</span>
}

// GetByAddress retrieves a wallet by address
func (s *SQLite) GetByAddress(ctx context.Context, address string) (*wallet.Wallet, error) <span class="cov8" title="1">{
        query := `
        SELECT id, name, address, keystore_path, encrypted_mnemonic, created_at, updated_at
        FROM wallets WHERE address = ?
        `

        row := s.db.QueryRowContext(ctx, query, address)

        var w wallet.Wallet
        var createdAt, updatedAt string

        err := row.Scan(&amp;w.ID, &amp;w.Name, &amp;w.Address, &amp;w.KeyStorePath, &amp;w.EncryptedMnemonic, &amp;createdAt, &amp;updatedAt)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("wallet not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to scan wallet: %w", err)</span>
        }

        <span class="cov8" title="1">if w.CreatedAt, err = time.Parse(time.RFC3339, createdAt); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse created_at: %w", err)
        }</span>

        <span class="cov8" title="1">if w.UpdatedAt, err = time.Parse(time.RFC3339, updatedAt); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse updated_at: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;w, nil</span>
}

// List retrieves all wallets
func (s *SQLite) List(ctx context.Context) ([]*wallet.Wallet, error) <span class="cov8" title="1">{
        query := `
        SELECT id, name, address, keystore_path, encrypted_mnemonic, created_at, updated_at
        FROM wallets ORDER BY created_at DESC
        `

        rows, err := s.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query wallets: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var wallets []*wallet.Wallet

        for rows.Next() </span><span class="cov8" title="1">{
                var w wallet.Wallet
                var createdAt, updatedAt string

                err := rows.Scan(&amp;w.ID, &amp;w.Name, &amp;w.Address, &amp;w.KeyStorePath, &amp;w.EncryptedMnemonic, &amp;createdAt, &amp;updatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan wallet: %w", err)
                }</span>

                <span class="cov8" title="1">if w.CreatedAt, err = time.Parse(time.RFC3339, createdAt); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse created_at: %w", err)
                }</span>

                <span class="cov8" title="1">if w.UpdatedAt, err = time.Parse(time.RFC3339, updatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse updated_at: %w", err)
                }</span>

                <span class="cov8" title="1">wallets = append(wallets, &amp;w)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to iterate over rows: %w", err)
        }</span>

        <span class="cov8" title="1">return wallets, nil</span>
}

// Update updates a wallet
func (s *SQLite) Update(ctx context.Context, w *wallet.Wallet) error <span class="cov8" title="1">{
        query := `
        UPDATE wallets 
        SET name = ?, address = ?, keystore_path = ?, encrypted_mnemonic = ?, updated_at = ?
        WHERE id = ?
        `

        _, err := s.db.ExecContext(ctx, query,
                w.Name, w.Address, w.KeyStorePath, w.EncryptedMnemonic, w.UpdatedAt, w.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update wallet: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Delete deletes a wallet
func (s *SQLite) Delete(ctx context.Context, id string) error <span class="cov8" title="1">{
        query := `DELETE FROM wallets WHERE id = ?`

        _, err := s.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete wallet: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Close closes the database connection
func (s *SQLite) Close() error <span class="cov8" title="1">{
        return s.db.Close()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package ui

import (
        "context"
        "fmt"

        "blocowallet/pkg/config"

        tea "github.com/charmbracelet/bubbletea"
)

// loadWalletsCmd loads all wallets from the service
func (m Model) loadWalletsCmd() tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                wallets, err := m.walletService.List(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg(err.Error())
                }</span>
                <span class="cov0" title="0">return walletsLoadedMsg(wallets)</span>
        })
}

// getBalanceCmd gets the balance for a given address
func (m Model) getBalanceCmd(address string) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                balance, err := m.walletService.GetBalance(context.Background(), address)
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg(err.Error())
                }</span>
                <span class="cov0" title="0">return balanceLoadedMsg(balance)</span>
        })
}

// getMultiBalanceCmd gets the balance for a given address across all active networks
func (m Model) getMultiBalanceCmd(address string) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                multiBalance, err := m.walletService.GetMultiNetworkBalance(context.Background(), address)
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg(err.Error())
                }</span>
                <span class="cov0" title="0">return multiBalanceLoadedMsg(multiBalance)</span>
        })
}

// createWalletCmd creates a new wallet with the given name and password
func (m Model) createWalletCmd(name, password string) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                _, err := m.walletService.CreateWalletWithMnemonic(context.Background(), name, password)
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg(err.Error())
                }</span>
                <span class="cov0" title="0">return walletCreatedMsg{}</span>
        })
}

// importWalletCmd imports a wallet from a mnemonic phrase
func (m Model) importWalletCmd(name, password, mnemonic string) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                _, err := m.walletService.ImportWalletFromMnemonic(context.Background(), name, mnemonic, password)
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg(err.Error())
                }</span>
                <span class="cov0" title="0">return walletCreatedMsg{}</span>
        })
}

// importWalletFromPrivateKeyCmd imports a wallet from a private key
func (m Model) importWalletFromPrivateKeyCmd(name, password, privateKey string) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                _, err := m.walletService.ImportWalletFromPrivateKey(context.Background(), name, privateKey, password)
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg(err.Error())
                }</span>
                <span class="cov0" title="0">return walletCreatedMsg{}</span>
        })
}

// Message types for network operations
type networkAddedMsg struct {
        key     string
        network config.Network
}

type networkErrorMsg string

// addNetworkCmd adds a custom network using ChainList API with retry
func (m Model) addNetworkCmd(name, chainIDStr, rpcEndpoint string) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                // Parse chain ID
                var chainID int
                if _, err := fmt.Sscanf(chainIDStr, "%d", &amp;chainID); err != nil </span><span class="cov0" title="0">{
                        return networkErrorMsg("Invalid chain ID: " + err.Error())
                }</span>

                // Get chain info with retry mechanism
                <span class="cov0" title="0">chainInfo, workingRPC, err := m.chainListService.GetChainInfoWithRetry(chainID)
                if err != nil </span><span class="cov0" title="0">{
                        return networkErrorMsg("Failed to fetch chain info: " + err.Error())
                }</span>

                // Use the working RPC from chainlist if no custom RPC provided
                <span class="cov0" title="0">finalRPC := rpcEndpoint
                if finalRPC == "" </span><span class="cov0" title="0">{
                        finalRPC = workingRPC
                }</span>

                // Create network configuration
                <span class="cov0" title="0">network := config.Network{
                        Name:        name,
                        RPCEndpoint: finalRPC,
                        ChainID:     int64(chainInfo.ChainID),
                        Symbol:      chainInfo.NativeCurrency.Symbol,
                        Explorer:    "",
                        IsActive:    false,
                        IsCustom:    true,
                }

                // Set explorer if available
                if len(chainInfo.Explorers) &gt; 0 </span><span class="cov0" title="0">{
                        network.Explorer = chainInfo.Explorers[0].URL
                }</span>

                // Generate a unique key
                <span class="cov0" title="0">key := fmt.Sprintf("custom_%d", chainID)

                return networkAddedMsg{
                        key:     key,
                        network: network,
                }</span>
        })
}

// searchNetworksCmd searches for network suggestions by name
func (m Model) searchNetworksCmd(query string) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                suggestions, err := m.chainListService.SearchNetworksByName(query)
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg("Failed to search networks: " + err.Error())
                }</span>
                <span class="cov0" title="0">return networkSuggestionsMsg(suggestions)</span>
        })
}

// loadChainInfoByIDCmd loads chain info using the new retry mechanism
func (m Model) loadChainInfoByIDCmd(chainID int) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                chainInfo, rpcURL, err := m.chainListService.GetChainInfoWithRetry(chainID)
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg("Failed to load chain info: " + err.Error())
                }</span>
                <span class="cov0" title="0">return chainInfoLoadedMsg{
                        chainInfo: chainInfo,
                        rpcURL:    rpcURL,
                }</span>
        })
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package ui

import (
        "github.com/charmbracelet/bubbles/key"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
        zone "github.com/lrstanley/bubblezone"
)

type DeleteWalletDialog struct {
        id         string
        width      int
        active     string
        question   string
        walletName string
        address    string
}

func NewDeleteWalletDialog(walletName, address string) DeleteWalletDialog <span class="cov0" title="0">{
        return DeleteWalletDialog{
                id:         "delete-wallet-dialog",
                active:     "cancel", // Comear com "cancel" ativo por segurana
                walletName: walletName,
                address:    address,
                question:   "Are you sure you want to delete this wallet?",
        }
}</span>

func (m DeleteWalletDialog) Init() tea.Cmd <span class="cov0" title="0">{
        return nil
}</span>

func (m DeleteWalletDialog) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.width = msg.Width</span>
        case tea.MouseMsg:<span class="cov0" title="0">
                if msg.Action != tea.MouseActionRelease || msg.Button != tea.MouseButtonLeft </span><span class="cov0" title="0">{
                        return m, nil
                }</span>

                <span class="cov0" title="0">if zone.Get(m.id + "confirm").InBounds(msg) </span><span class="cov0" title="0">{
                        m.active = "confirm"
                        return m, func() tea.Msg </span><span class="cov0" title="0">{ return ConfirmDeleteMsg{} }</span>
                } else<span class="cov0" title="0"> if zone.Get(m.id + "cancel").InBounds(msg) </span><span class="cov0" title="0">{
                        m.active = "cancel"
                        return m, func() tea.Msg </span><span class="cov0" title="0">{ return CancelDeleteMsg{} }</span>
                }

                <span class="cov0" title="0">return m, nil</span>
        case tea.KeyMsg:<span class="cov0" title="0">
                switch </span>{
                case key.Matches(msg, key.NewBinding(key.WithKeys("left", "h"))):<span class="cov0" title="0">
                        if m.active == "confirm" </span><span class="cov0" title="0">{
                                m.active = "cancel"
                        }</span> else<span class="cov0" title="0"> {
                                m.active = "confirm"
                        }</span>
                case key.Matches(msg, key.NewBinding(key.WithKeys("right", "l"))):<span class="cov0" title="0">
                        if m.active == "cancel" </span><span class="cov0" title="0">{
                                m.active = "confirm"
                        }</span> else<span class="cov0" title="0"> {
                                m.active = "cancel"
                        }</span>
                case key.Matches(msg, key.NewBinding(key.WithKeys("enter"))):<span class="cov0" title="0">
                        if m.active == "confirm" </span><span class="cov0" title="0">{
                                return m, func() tea.Msg </span><span class="cov0" title="0">{ return ConfirmDeleteMsg{} }</span>
                        } else<span class="cov0" title="0"> {
                                return m, func() tea.Msg </span><span class="cov0" title="0">{ return CancelDeleteMsg{} }</span>
                        }
                case key.Matches(msg, key.NewBinding(key.WithKeys("esc"))):<span class="cov0" title="0">
                        return m, func() tea.Msg </span><span class="cov0" title="0">{ return CancelDeleteMsg{} }</span>
                }
        }
        <span class="cov0" title="0">return m, nil</span>
}

func (m DeleteWalletDialog) View() string <span class="cov0" title="0">{
        var confirmButton, cancelButton string

        if m.active == "confirm" </span><span class="cov0" title="0">{
                confirmButton = activeButtonStyle.Render("Yes, Delete")
                cancelButton = buttonStyle.Render("Cancel")
        }</span> else<span class="cov0" title="0"> {
                confirmButton = buttonStyle.Render("Yes, Delete")
                cancelButton = activeButtonStyle.Render("Cancel")
        }</span>

        // Criar a pergunta com o nome da wallet
        <span class="cov0" title="0">questionText := lipgloss.JoinVertical(
                lipgloss.Center,
                m.question,
                "",
                lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#ff6b6b")).
                        Bold(true).
                        Render("\""+m.walletName+"\""),
                "",
                lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#8a8a8a")).
                        Render(m.address[:10]+"..."+m.address[len(m.address)-10:]),
                "",
                lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#666666")).
                        Render("This action cannot be undone."),
        )

        question := lipgloss.NewStyle().
                Width(45).
                Align(lipgloss.Center).
                Render(questionText)

        buttons := lipgloss.JoinHorizontal(
                lipgloss.Top,
                zone.Mark(m.id+"cancel", cancelButton),
                "  ",
                zone.Mark(m.id+"confirm", confirmButton),
        )

        return dialogBoxStyle.Render(
                lipgloss.JoinVertical(
                        lipgloss.Center,
                        question,
                        "",
                        buttons,
                ),
        )</span>
}

// Mensagens para comunicao
type ConfirmDeleteMsg struct{}
type CancelDeleteMsg struct{}

// Estilos
var (
        dialogBoxStyle = lipgloss.NewStyle().
                        Border(lipgloss.RoundedBorder()).
                        BorderForeground(lipgloss.Color("#874BFD")).
                        Padding(2, 3).
                        Background(lipgloss.Color("#1a1a1a")).
                        Foreground(lipgloss.Color("#ffffff")).
                        MarginTop(2).
                        MarginBottom(2)

        buttonStyle = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#FFF")).
                        Background(lipgloss.Color("#666")).
                        Padding(0, 3).
                        Margin(0, 1).
                        Border(lipgloss.RoundedBorder())

        activeButtonStyle = lipgloss.NewStyle().
                                Foreground(lipgloss.Color("#FFF")).
                                Background(lipgloss.Color("#874BFD")).
                                Padding(0, 3).
                                Margin(0, 1).
                                Bold(true).
                                Border(lipgloss.RoundedBorder())
)
</pre>
		
		<pre class="file" id="file7" style="display: none">package ui

import (
        "fmt"
        "strings"

        "blocowallet/internal/blockchain"
        "blocowallet/pkg/config"

        tea "github.com/charmbracelet/bubbletea"
)

// handleInputNavigation handles navigation between input fields
func (m Model) handleInputNavigation(msg tea.KeyMsg) (Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "tab", "down":<span class="cov0" title="0">
                m.inputFocus = (m.inputFocus + 1) % 3
                if m.currentView == CreateWalletView </span><span class="cov0" title="0">{
                        m.inputFocus = m.inputFocus % 2 // Only 2 fields in create view
                }</span>
        case "shift+tab", "up":<span class="cov0" title="0">
                m.inputFocus--
                if m.inputFocus &lt; 0 </span><span class="cov0" title="0">{
                        if m.currentView == CreateWalletView </span><span class="cov0" title="0">{
                                m.inputFocus = 1
                        }</span> else<span class="cov0" title="0"> {
                                m.inputFocus = 2
                        }</span>
                }
        }

        <span class="cov0" title="0">m.updateInputFocus()

        return m, nil</span>
}

// handleInputSubmit handles form submission in input views
func (m Model) handleInputSubmit() (Model, tea.Cmd) <span class="cov0" title="0">{
        if m.currentView == CreateWalletView </span><span class="cov0" title="0">{
                name := strings.TrimSpace(m.nameInput.Value())
                password := strings.TrimSpace(m.passwordInput.Value())

                if name == "" || password == "" </span><span class="cov0" title="0">{
                        m.err = fmt.Errorf("name and password are required")
                        return m, nil
                }</span>

                <span class="cov0" title="0">return m, m.createWalletCmd(name, password)</span>
        } else<span class="cov0" title="0"> if m.currentView == ImportWalletView </span><span class="cov0" title="0">{
                name := strings.TrimSpace(m.nameInput.Value())
                password := strings.TrimSpace(m.passwordInput.Value())
                mnemonic := strings.TrimSpace(m.mnemonicInput.Value())

                if name == "" || password == "" </span><span class="cov0" title="0">{
                        m.err = fmt.Errorf("name and password are required")
                        return m, nil
                }</span>

                <span class="cov0" title="0">if mnemonic == "" </span><span class="cov0" title="0">{
                        m.err = fmt.Errorf("mnemonic phrase is required")
                        return m, nil
                }</span>

                <span class="cov0" title="0">return m, m.importWalletCmd(name, password, mnemonic)</span>
        } else<span class="cov0" title="0"> if m.currentView == ImportPrivateKeyView </span><span class="cov0" title="0">{
                name := strings.TrimSpace(m.nameInput.Value())
                password := strings.TrimSpace(m.passwordInput.Value())
                privateKey := strings.TrimSpace(m.privateKeyInput.Value())

                if name == "" || password == "" </span><span class="cov0" title="0">{
                        m.err = fmt.Errorf("name and password are required")
                        return m, nil
                }</span>

                <span class="cov0" title="0">if privateKey == "" </span><span class="cov0" title="0">{
                        m.err = fmt.Errorf("private key is required")
                        return m, nil
                }</span>

                <span class="cov0" title="0">return m, m.importWalletFromPrivateKeyCmd(name, password, privateKey)</span>
        } else<span class="cov0" title="0"> if m.currentView == WalletAuthView </span><span class="cov0" title="0">{
                // Handle wallet authentication
                password := strings.TrimSpace(m.walletAuthPassword.Value())
                if password == "" </span><span class="cov0" title="0">{
                        m.walletAuthError = "Password cannot be empty"
                        return m, nil
                }</span>

                // Try to validate keystore with password
                <span class="cov0" title="0">_, err := m.walletService.ExtractPrivateKeyFromKeystore(m.selectedWallet.KeyStorePath, password)
                if err != nil </span><span class="cov0" title="0">{
                        m.walletAuthError = fmt.Sprintf("Invalid password: %v", err)
                        m.walletAuthPassword.SetValue("")
                        return m, nil
                }</span>

                // Authentication successful, store password and proceed to details
                <span class="cov0" title="0">m.walletService.SetWalletPassword(m.selectedWallet.Address, password)
                m.needsWalletAuth = false
                m.walletAuthError = ""
                m.walletAuthPassword.SetValue("")
                m.walletAuthPassword.Blur()
                m.currentView = WalletDetailsView
                return m, m.getMultiBalanceCmd(m.selectedWallet.Address)</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// handleEnterKey handles the enter key press for navigation
func (m Model) handleEnterKey() (Model, tea.Cmd) <span class="cov0" title="0">{
        switch m.currentView </span>{
        case SplashView:<span class="cov0" title="0">
                m.currentView = MenuView
                m.selected = 0
                return m, nil</span>

        case MenuView:<span class="cov0" title="0">
                switch m.selected </span>{
                case 0:<span class="cov0" title="0"> // View Wallets
                        m.currentView = WalletListView
                        m.selected = 0
                        return m, m.loadWalletsCmd()</span>
                case 1:<span class="cov0" title="0"> // Create New Wallet
                        m.currentView = CreateWalletView
                        m.resetInputs()
                        m.nameInput.Focus()
                        return m, nil</span>
                case 2:<span class="cov0" title="0"> // Import Wallet (Mnemonic)
                        m.currentView = ImportWalletView
                        m.resetInputs()
                        m.nameInput.Focus()
                        return m, nil</span>
                case 3:<span class="cov0" title="0"> // Import Wallet (Private Key)
                        m.currentView = ImportPrivateKeyView
                        m.resetInputs()
                        m.nameInput.Focus()
                        return m, nil</span>
                case 4:<span class="cov0" title="0"> // Settings
                        m.currentView = SettingsView
                        m.settingsSelected = 0
                        return m, nil</span>
                case 5:<span class="cov0" title="0"> // Exit
                        return m, tea.Quit</span>
                }

        case WalletListView:<span class="cov0" title="0">
                if len(m.wallets) &gt; 0 &amp;&amp; m.selected &lt; len(m.wallets) </span><span class="cov0" title="0">{
                        m.selectedWallet = m.wallets[m.selected]

                        // Reset extracted private key when switching wallets
                        m.extractedPrivateKey = ""

                        // Check if wallet needs authentication (has keystore)
                        if m.selectedWallet.KeyStorePath != "" </span><span class="cov0" title="0">{
                                m.needsWalletAuth = true
                                m.walletAuthPassword.Reset()
                                m.walletAuthPassword.Focus()
                                m.walletAuthError = ""
                                m.currentView = WalletAuthView
                                return m, nil
                        }</span> else<span class="cov0" title="0"> {
                                // Wallet doesn't need auth, go directly to details
                                m.currentView = WalletDetailsView
                                return m, m.getMultiBalanceCmd(m.selectedWallet.Address)
                        }</span>
                }

        case SettingsView:<span class="cov0" title="0">
                switch m.settingsSelected </span>{
                case 0:<span class="cov0" title="0"> // Network Configuration
                        m.currentView = NetworkConfigView
                        m.networkSelected = 0
                        return m, nil</span>
                case 1:<span class="cov0" title="0"> // Language
                        m.currentView = LanguageView
                        m.languageSelected = 0
                        return m, nil</span>
                case 2:<span class="cov0" title="0"> // Back to Main Menu
                        m.currentView = MenuView
                        m.selected = 0
                        return m, nil</span>
                }

        case NetworkConfigView:<span class="cov0" title="0">
                if m.editingRPC </span><span class="cov0" title="0">{
                        // Save RPC change
                        m.editingRPC = false
                        m.rpcInput.Blur()
                        return m.saveRPCEndpoint()
                }</span> else<span class="cov0" title="0"> {
                        networkKeys := m.config.GetAllNetworkKeys()
                        if m.networkSelected &lt; len(networkKeys) </span><span class="cov0" title="0">{
                                // View network details
                                key := networkKeys[m.networkSelected]
                                m.selectedNetworkKey = key
                                m.currentView = NetworkDetailsView
                                return m, nil
                        }</span> else<span class="cov0" title="0"> if m.networkSelected == len(networkKeys) </span><span class="cov0" title="0">{
                                // Add Custom Network
                                m.currentView = AddNetworkView
                                m.addNetworkFocus = 0
                                m.networkNameInput.Focus()
                                m.networkNameInput.SetValue("")
                                m.chainIDInput.SetValue("")
                                m.rpcEndpointInput.SetValue("")
                                return m, nil
                        }</span> else<span class="cov0" title="0"> if m.networkSelected == len(networkKeys)+1 </span><span class="cov0" title="0">{
                                // Back to Settings
                                m.currentView = SettingsView
                                m.settingsSelected = 0
                                return m, nil
                        }</span>
                }

        case LanguageView:<span class="cov0" title="0">
                langCodes := m.config.GetLanguageCodes()
                if m.languageSelected &lt; len(langCodes) </span><span class="cov0" title="0">{
                        // Change language
                        langCode := langCodes[m.languageSelected]
                        m.config.Language = langCode
                        return m.saveLanguageChange()
                }</span> else<span class="cov0" title="0"> if m.languageSelected == len(langCodes) </span><span class="cov0" title="0">{
                        // Back to Settings
                        m.currentView = SettingsView
                        m.settingsSelected = 0
                        return m, nil
                }</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// saveRPCEndpoint saves the edited RPC endpoint
func (m Model) saveRPCEndpoint() (Model, tea.Cmd) <span class="cov0" title="0">{
        networkKeys := m.config.GetAllNetworkKeys()
        if m.networkSelected &lt; len(networkKeys) </span><span class="cov0" title="0">{
                key := networkKeys[m.networkSelected]
                if network, exists := m.config.GetNetworkByKey(key); exists </span><span class="cov0" title="0">{
                        network.RPCEndpoint = strings.TrimSpace(m.rpcInput.Value())
                        m.config.UpdateNetwork(key, network)

                        // Save configuration to file
                        if err := m.config.Save(); err != nil </span><span class="cov0" title="0">{
                                m.err = err
                        }</span>

                        // Update network items
                        <span class="cov0" title="0">m.refreshNetworkItems()</span>
                }
        }
        <span class="cov0" title="0">return m, nil</span>
}

// saveLanguageChange saves the language change and updates UI
func (m Model) saveLanguageChange() (Model, tea.Cmd) <span class="cov0" title="0">{
        // Save configuration to file
        if err := m.config.Save(); err != nil </span><span class="cov0" title="0">{
                m.err = err
        }</span>

        // Update language items to reflect the change
        <span class="cov0" title="0">m.languageItems = m.buildLanguageItems()

        // Go back to settings
        m.currentView = SettingsView
        m.settingsSelected = 0
        return m, nil</span>
}

// buildNetworkItems creates the network items list
func (m Model) buildNetworkItems() []string <span class="cov0" title="0">{
        var items []string
        networkKeys := m.config.GetAllNetworkKeys()
        for _, key := range networkKeys </span><span class="cov0" title="0">{
                if network, exists := m.config.GetNetworkByKey(key); exists </span><span class="cov0" title="0">{
                        status := ""
                        if network.IsActive </span><span class="cov0" title="0">{
                                status = " (Active)"
                        }</span>
                        <span class="cov0" title="0">customTag := ""
                        if network.IsCustom </span><span class="cov0" title="0">{
                                customTag = " [Custom]"
                        }</span>
                        <span class="cov0" title="0">items = append(items, fmt.Sprintf("%s%s%s", network.Name, status, customTag))</span>
                }
        }
        <span class="cov0" title="0">items = append(items, "Add Custom Network", "Back to Settings")
        return items</span>
}

// buildLanguageItems creates the language items list
func (m Model) buildLanguageItems() []string <span class="cov0" title="0">{
        var items []string
        langCodes := m.config.GetLanguageCodes()
        for _, code := range langCodes </span><span class="cov0" title="0">{
                name := config.SupportedLanguages[code]
                status := ""
                if m.config.Language == code </span><span class="cov0" title="0">{
                        status = " (Current)"
                }</span>
                <span class="cov0" title="0">items = append(items, fmt.Sprintf("%s%s", name, status))</span>
        }
        <span class="cov0" title="0">items = append(items, "Back to Settings")
        return items</span>
}

// updateInputFocus updates which input field has focus
func (m *Model) updateInputFocus() <span class="cov0" title="0">{
        // First, blur all inputs
        m.nameInput.Blur()
        m.passwordInput.Blur()
        m.mnemonicInput.Blur()
        m.privateKeyInput.Blur()

        // Then focus the current one
        switch m.inputFocus </span>{
        case 0:<span class="cov0" title="0">
                m.nameInput.Focus()</span>
        case 1:<span class="cov0" title="0">
                m.passwordInput.Focus()</span>
        case 2:<span class="cov0" title="0">
                if m.currentView == ImportWalletView </span><span class="cov0" title="0">{
                        m.mnemonicInput.Focus()
                }</span> else<span class="cov0" title="0"> if m.currentView == ImportPrivateKeyView </span><span class="cov0" title="0">{
                        m.privateKeyInput.Focus()
                }</span>
        }
}

// resetInputs resets all input fields to their default state
func (m *Model) resetInputs() <span class="cov0" title="0">{
        m.nameInput.SetValue("")
        m.passwordInput.SetValue("")
        m.mnemonicInput.SetValue("")
        m.inputFocus = 0
        m.nameInput.Focus()
        m.passwordInput.Blur()
        m.mnemonicInput.Blur()
        m.err = nil
}</span>

// handleAddNetworkNavigation handles navigation in add network view
func (m Model) handleAddNetworkNavigation(msg tea.KeyMsg) (Model, tea.Cmd) <span class="cov0" title="0">{
        // If showing suggestions, handle suggestion navigation
        if m.showingSuggestions &amp;&amp; m.addNetworkFocus == 0 </span><span class="cov0" title="0">{ // Only when on network name field
                switch msg.String() </span>{
                case "down":<span class="cov0" title="0">
                        if m.selectedSuggestion &lt; len(m.networkSuggestions)-1 </span><span class="cov0" title="0">{
                                m.selectedSuggestion++
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>
                case "up":<span class="cov0" title="0">
                        if m.selectedSuggestion &gt; 0 </span><span class="cov0" title="0">{
                                m.selectedSuggestion--
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>
                case "enter":<span class="cov0" title="0">
                        // Select the current suggestion
                        if m.selectedSuggestion &lt; len(m.networkSuggestions) </span><span class="cov0" title="0">{
                                suggestion := m.networkSuggestions[m.selectedSuggestion]
                                m.networkNameInput.SetValue(suggestion.Name)
                                m.chainIDInput.SetValue(fmt.Sprintf("%d", suggestion.ChainID))
                                m.showingSuggestions = false
                                m.addNetworkFocus = 1 // Move to Chain ID field
                                m.updateAddNetworkFocus()

                                // Load chain info to auto-fill RPC
                                return m, m.loadChainInfoByIDCmd(suggestion.ChainID)
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>
                case "esc":<span class="cov0" title="0">
                        m.showingSuggestions = false
                        return m, nil</span>
                }
        }

        // Regular navigation
        <span class="cov0" title="0">switch msg.String() </span>{
        case "tab", "down":<span class="cov0" title="0">
                if !m.showingSuggestions </span><span class="cov0" title="0">{
                        m.addNetworkFocus = (m.addNetworkFocus + 1) % 3
                }</span>
        case "shift+tab", "up":<span class="cov0" title="0">
                if !m.showingSuggestions </span><span class="cov0" title="0">{
                        m.addNetworkFocus--
                        if m.addNetworkFocus &lt; 0 </span><span class="cov0" title="0">{
                                m.addNetworkFocus = 2
                        }</span>
                }
        }

        <span class="cov0" title="0">m.updateAddNetworkFocus()
        return m, nil</span>
}

// updateAddNetworkFocus updates which input field has focus in add network view
func (m *Model) updateAddNetworkFocus() <span class="cov0" title="0">{
        m.networkNameInput.Blur()
        m.chainIDInput.Blur()
        m.rpcEndpointInput.Blur()

        switch m.addNetworkFocus </span>{
        case 0:<span class="cov0" title="0">
                m.networkNameInput.Focus()</span>
        case 1:<span class="cov0" title="0">
                m.chainIDInput.Focus()</span>
        case 2:<span class="cov0" title="0">
                m.rpcEndpointInput.Focus()</span>
        }
}

// resetAddNetworkInputs resets the inputs in the add network view
func (m *Model) resetAddNetworkInputs() <span class="cov0" title="0">{
        m.networkNameInput.SetValue("")
        m.chainIDInput.SetValue("")
        m.rpcEndpointInput.SetValue("")
        m.addNetworkFocus = 0
        m.networkNameInput.Focus()
        m.chainIDInput.Blur()
        m.rpcEndpointInput.Blur()
        m.showingSuggestions = false
        m.networkSuggestions = []blockchain.NetworkSuggestion{}
        m.selectedSuggestion = 0
        m.err = nil
}</span>

// handleAddNetworkSubmit handles the submission of add network form
func (m Model) handleAddNetworkSubmit() (Model, tea.Cmd) <span class="cov0" title="0">{
        name := strings.TrimSpace(m.networkNameInput.Value())
        chainIDStr := strings.TrimSpace(m.chainIDInput.Value())
        rpcEndpoint := strings.TrimSpace(m.rpcEndpointInput.Value())

        if name == "" || chainIDStr == "" || rpcEndpoint == "" </span><span class="cov0" title="0">{
                m.err = fmt.Errorf("all fields are required")
                return m, nil
        }</span>

        <span class="cov0" title="0">m.addingNetwork = true
        return m, m.addNetworkCmd(name, chainIDStr, rpcEndpoint)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package ui

import (
        "fmt"
        "strconv"
        "strings"

        "blocowallet/internal/blockchain"
        "blocowallet/pkg/config"

        tea "github.com/charmbracelet/bubbletea"
)

// NetworkOperations contm operaes especficas de rede que podem ser reutilizadas
type NetworkOperations struct {
        config           *config.Config
        chainListService *blockchain.ChainListService
}

// NewNetworkOperations cria uma nova instncia de NetworkOperations
func NewNetworkOperations(cfg *config.Config, chainListService *blockchain.ChainListService) *NetworkOperations <span class="cov0" title="0">{
        return &amp;NetworkOperations{
                config:           cfg,
                chainListService: chainListService,
        }
}</span>

// GetAllNetworks retorna todas as redes configuradas
func (no *NetworkOperations) GetAllNetworks() []string <span class="cov0" title="0">{
        var networkItems []string
        networkKeys := no.config.GetAllNetworkKeys()
        for _, key := range networkKeys </span><span class="cov0" title="0">{
                if network, exists := no.config.GetNetworkByKey(key); exists </span><span class="cov0" title="0">{
                        status := ""
                        if network.IsActive </span><span class="cov0" title="0">{
                                status = " (Active)"
                        }</span>
                        <span class="cov0" title="0">customTag := ""
                        if network.IsCustom </span><span class="cov0" title="0">{
                                customTag = " [Custom]"
                        }</span>
                        <span class="cov0" title="0">networkItems = append(networkItems, fmt.Sprintf("%s%s%s", network.Name, status, customTag))</span>
                }
        }
        <span class="cov0" title="0">return networkItems</span>
}

// ToggleNetworkActive alterna o status ativo de uma rede
func (no *NetworkOperations) ToggleNetworkActive(networkKey string) error <span class="cov0" title="0">{
        return no.config.ToggleNetworkActive(networkKey)
}</span>

// UpdateNetworkRPC atualiza o endpoint RPC de uma rede
func (no *NetworkOperations) UpdateNetworkRPC(networkKey, rpcEndpoint string) error <span class="cov0" title="0">{
        if network, exists := no.config.GetNetworkByKey(networkKey); exists </span><span class="cov0" title="0">{
                network.RPCEndpoint = strings.TrimSpace(rpcEndpoint)
                if network.IsCustom </span><span class="cov0" title="0">{
                        no.config.CustomNetworks[networkKey] = network
                }</span> else<span class="cov0" title="0"> {
                        no.config.Networks[networkKey] = network
                }</span>
                <span class="cov0" title="0">return no.config.Save()</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("network not found: %s", networkKey)</span>
}

// AddCustomNetwork adiciona uma rede personalizada
func (no *NetworkOperations) AddCustomNetwork(name, chainID, rpcEndpoint string) (string, error) <span class="cov0" title="0">{
        // Validate input
        if err := ValidateNetworkInput(name, chainID, rpcEndpoint); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Parse chain ID
        <span class="cov0" title="0">chainIDInt, err := strconv.Atoi(strings.TrimSpace(chainID))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid chain ID: %s", chainID)
        }</span>

        // Create network key
        <span class="cov0" title="0">key := fmt.Sprintf("custom_%d", chainIDInt)

        // Create network configuration
        network := config.Network{
                Name:        strings.TrimSpace(name),
                ChainID:     int64(chainIDInt),
                RPCEndpoint: strings.TrimSpace(rpcEndpoint),
                Symbol:      "ETH", // Default symbol
                IsActive:    true,  // New networks are active by default
                IsCustom:    true,
        }

        // Add to config
        no.config.AddCustomNetwork(key, network)
        return key, no.config.Save()</span>
}

// SearchNetworks busca redes por nome
func (no *NetworkOperations) SearchNetworks(query string) ([]blockchain.NetworkSuggestion, error) <span class="cov0" title="0">{
        if no.chainListService == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("chain list service not available")
        }</span>
        <span class="cov0" title="0">return no.chainListService.SearchNetworksByName(query)</span>
}

// GetChainInfoByID obtm informaes de uma chain pelo ID
func (no *NetworkOperations) GetChainInfoByID(chainID int) (*blockchain.ChainInfo, string, error) <span class="cov0" title="0">{
        if no.chainListService == nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("chain list service not available")
        }</span>
        <span class="cov0" title="0">return no.chainListService.GetChainInfoWithRetry(chainID)</span>
}

// ValidateNetworkInput valida os dados de entrada para adio de rede
func ValidateNetworkInput(name, chainID, rpcEndpoint string) error <span class="cov8" title="1">{
        name = strings.TrimSpace(name)
        chainID = strings.TrimSpace(chainID)
        rpcEndpoint = strings.TrimSpace(rpcEndpoint)

        if name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("network name is required")
        }</span>
        <span class="cov8" title="1">if chainID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("chain ID is required")
        }</span>
        <span class="cov8" title="1">if rpcEndpoint == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("RPC endpoint is required")
        }</span>

        // Validate chain ID is numeric
        <span class="cov8" title="1">if _, err := strconv.Atoi(chainID); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("chain ID must be a number")
        }</span>

        // Validate RPC endpoint format
        <span class="cov8" title="1">if !strings.HasPrefix(rpcEndpoint, "http://") &amp;&amp; !strings.HasPrefix(rpcEndpoint, "https://") </span><span class="cov8" title="1">{
                return fmt.Errorf("RPC endpoint must start with http:// or https://")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetLanguages retorna os idiomas suportados
func (no *NetworkOperations) GetLanguages() []string <span class="cov0" title="0">{
        var languageItems []string
        langCodes := no.config.GetLanguageCodes()
        for _, code := range langCodes </span><span class="cov0" title="0">{
                name := config.SupportedLanguages[code]
                status := ""
                if no.config.Language == code </span><span class="cov0" title="0">{
                        status = " (Current)"
                }</span>
                <span class="cov0" title="0">languageItems = append(languageItems, fmt.Sprintf("%s%s", name, status))</span>
        }
        <span class="cov0" title="0">return languageItems</span>
}

// ChangeLanguage altera o idioma da aplicao
func (no *NetworkOperations) ChangeLanguage(languageCode string) error <span class="cov0" title="0">{
        no.config.Language = languageCode
        return no.config.Save()
}</span>

// NetworkMessages define types para operaes de rede
type NetworkAddedMsg struct {
        Key     string
        Network config.Network
}
type NetworkErrorMsg string

func SearchNetworksCmd(no *NetworkOperations, query string) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                suggestions, err := no.SearchNetworks(query)
                if err != nil </span><span class="cov0" title="0">{
                        return NetworkErrorMsg(err.Error())
                }</span>
                <span class="cov0" title="0">return networkSuggestionsMsg(suggestions)</span>
        })
}

func LoadChainInfoByIDCmd(no *NetworkOperations, chainID int) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                chainInfo, rpcURL, err := no.GetChainInfoByID(chainID)
                if err != nil </span><span class="cov0" title="0">{
                        return NetworkErrorMsg(err.Error())
                }</span>
                <span class="cov0" title="0">return chainInfoLoadedMsg{
                        chainInfo: chainInfo,
                        rpcURL:    rpcURL,
                }</span>
        })
}

func AddNetworkCmd(no *NetworkOperations, name, chainID, rpcEndpoint string) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                key, err := no.AddCustomNetwork(name, chainID, rpcEndpoint)
                if err != nil </span><span class="cov0" title="0">{
                        return NetworkErrorMsg(err.Error())
                }</span>

                // Get the added network for the message
                <span class="cov0" title="0">if network, exists := no.config.GetNetworkByKey(key); exists </span><span class="cov0" title="0">{
                        return NetworkAddedMsg{
                                Key:     key,
                                Network: network,
                        }
                }</span>

                <span class="cov0" title="0">return NetworkErrorMsg("failed to retrieve added network")</span>
        })
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package ui

import (
        "fmt"
        "strings"

        "github.com/charmbracelet/lipgloss"
)

// renderSettings renders the main settings menu
func (m Model) renderSettings() string <span class="cov0" title="0">{
        var b strings.Builder

        headerStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                MarginBottom(2)

        itemStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("240"))

        selectedStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                Background(lipgloss.Color("235"))

        b.WriteString(headerStyle.Render("  Settings"))
        b.WriteString("\n\n")

        for i, item := range m.settingsItems </span><span class="cov0" title="0">{
                style := itemStyle
                if i == m.settingsSelected </span><span class="cov0" title="0">{
                        style = selectedStyle
                }</span>

                <span class="cov0" title="0">prefix := "  "
                if i == m.settingsSelected </span><span class="cov0" title="0">{
                        prefix = " "
                }</span>

                <span class="cov0" title="0">b.WriteString(style.Render(prefix + item))
                b.WriteString("\n")</span>
        }

        <span class="cov0" title="0">b.WriteString("\n")
        b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("240")).Render("/: Navigate  Enter: Select  Esc: Back"))

        return b.String()</span>
}

// renderNetworkConfig renders the network configuration view
func (m Model) renderNetworkConfig() string <span class="cov0" title="0">{
        var b strings.Builder

        headerStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                MarginBottom(2)

        itemStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("240"))

        selectedStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                Background(lipgloss.Color("235"))

        b.WriteString(headerStyle.Render(" Network Configuration"))
        b.WriteString("\n\n")

        if m.editingRPC </span><span class="cov0" title="0">{
                b.WriteString("Edit RPC Endpoint:\n\n")
                b.WriteString(m.rpcInput.View())
                b.WriteString("\n\n")
                b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("240")).Render("Enter: Save  Esc: Cancel"))
        }</span> else<span class="cov0" title="0"> {
                for i, item := range m.networkItems </span><span class="cov0" title="0">{
                        style := itemStyle
                        if i == m.networkSelected </span><span class="cov0" title="0">{
                                style = selectedStyle
                        }</span>

                        <span class="cov0" title="0">prefix := "  "
                        if i == m.networkSelected </span><span class="cov0" title="0">{
                                prefix = " "
                        }</span>

                        <span class="cov0" title="0">b.WriteString(style.Render(prefix + item))
                        b.WriteString("\n")</span>
                }

                <span class="cov0" title="0">b.WriteString("\n")

                // Show different help text based on selected item
                networkKeys := m.config.GetAllNetworkKeys()
                if m.networkSelected &lt; len(networkKeys) </span><span class="cov0" title="0">{
                        key := networkKeys[m.networkSelected]
                        if network, exists := m.config.GetNetworkByKey(key); exists </span><span class="cov0" title="0">{
                                helpText := "/: Navigate  Enter: Details  A: Toggle Active  E: Edit RPC"
                                if network.IsCustom </span><span class="cov0" title="0">{
                                        helpText += "  D: Delete"
                                }</span>
                                <span class="cov0" title="0">helpText += "  Esc: Back"
                                b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("240")).Render(helpText))</span>
                        }
                } else<span class="cov0" title="0"> {
                        // For "Add Custom Network" and "Back to Settings"
                        b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("240")).Render("/: Navigate  Enter: Select  Esc: Back"))
                }</span>
        }

        <span class="cov0" title="0">return b.String()</span>
}

// renderLanguage renders the language selection view
func (m Model) renderLanguage() string <span class="cov0" title="0">{
        var b strings.Builder

        headerStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                MarginBottom(2)

        itemStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("240"))

        selectedStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                Background(lipgloss.Color("235"))

        b.WriteString(headerStyle.Render(" Language Selection"))
        b.WriteString("\n\n")

        for i, item := range m.languageItems </span><span class="cov0" title="0">{
                style := itemStyle
                if i == m.languageSelected </span><span class="cov0" title="0">{
                        style = selectedStyle
                }</span>

                <span class="cov0" title="0">prefix := "  "
                if i == m.languageSelected </span><span class="cov0" title="0">{
                        prefix = " "
                }</span>

                <span class="cov0" title="0">b.WriteString(style.Render(prefix + item))
                b.WriteString("\n")</span>
        }

        <span class="cov0" title="0">b.WriteString("\n")
        b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("240")).Render("/: Navigate  Enter: Select  Esc: Back"))

        return b.String()</span>
}

// renderAddNetwork renders the add custom network view
func (m Model) renderAddNetwork() string <span class="cov0" title="0">{
        var b strings.Builder

        headerStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                MarginBottom(2)

        inputStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("240")).
                MarginBottom(1)

        focusedStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                Background(lipgloss.Color("235")).
                MarginBottom(1)

        b.WriteString(headerStyle.Render(" Add Custom Network"))
        b.WriteString("\n\n")

        // Network Name input
        nameLabel := "Network Name:"
        nameStyle := inputStyle
        if m.addNetworkFocus == 0 </span><span class="cov0" title="0">{
                nameStyle = focusedStyle
        }</span>
        <span class="cov0" title="0">b.WriteString(nameStyle.Render(nameLabel))
        b.WriteString("\n")
        b.WriteString(m.networkNameInput.View())

        // Show network suggestions if available
        if m.showingSuggestions &amp;&amp; len(m.networkSuggestions) &gt; 0 &amp;&amp; m.addNetworkFocus == 0 </span><span class="cov0" title="0">{
                suggestionStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("244")).
                        Background(lipgloss.Color("236")).
                        Padding(0, 1).
                        MarginTop(1)

                selectedSuggestionStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("15")). // White text
                        Background(lipgloss.Color("86")). // Green background
                        Padding(0, 1).
                        Bold(true)

                b.WriteString("\n")
                b.WriteString(lipgloss.NewStyle().
                        Foreground(lipgloss.Color("86")).
                        Bold(true).
                        Render(" Suggestions (Press Enter to select):"))
                b.WriteString("\n")

                for i, suggestion := range m.networkSuggestions </span><span class="cov0" title="0">{
                        style := suggestionStyle
                        prefix := "  "
                        if i == m.selectedSuggestion </span><span class="cov0" title="0">{
                                style = selectedSuggestionStyle
                                prefix = " " // Arrow indicator for selected item
                        }</span>

                        <span class="cov0" title="0">suggestionText := fmt.Sprintf("%s%s (Chain ID: %d, Symbol: %s)",
                                prefix, suggestion.Name, suggestion.ChainID, suggestion.Symbol)
                        b.WriteString(style.Render(suggestionText))
                        b.WriteString("\n")</span>
                }

                <span class="cov0" title="0">b.WriteString(lipgloss.NewStyle().
                        Foreground(lipgloss.Color("240")).
                        Render("/: Navigate suggestions  Enter: Select  Esc: Close"))</span>
        }

        <span class="cov0" title="0">b.WriteString("\n\n")

        // Chain ID input
        chainLabel := "Chain ID:"
        chainStyle := inputStyle
        if m.addNetworkFocus == 1 </span><span class="cov0" title="0">{
                chainStyle = focusedStyle
        }</span>
        <span class="cov0" title="0">b.WriteString(chainStyle.Render(chainLabel))
        b.WriteString("\n")
        b.WriteString(m.chainIDInput.View())
        b.WriteString("\n\n")

        // RPC Endpoint input
        rpcLabel := "RPC Endpoint (optional - auto-filled from ChainList):"
        rpcStyle := inputStyle
        if m.addNetworkFocus == 2 </span><span class="cov0" title="0">{
                rpcStyle = focusedStyle
        }</span>
        <span class="cov0" title="0">b.WriteString(rpcStyle.Render(rpcLabel))
        b.WriteString("\n")
        b.WriteString(m.rpcEndpointInput.View())
        b.WriteString("\n\n")

        if m.addingNetwork </span><span class="cov0" title="0">{
                b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("202")).Render(" Adding network and finding best RPC endpoint..."))
                b.WriteString("\n\n")
        }</span>

        <span class="cov0" title="0">if m.err != nil </span><span class="cov0" title="0">{
                b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("196")).Render(" Error: " + m.err.Error()))
                b.WriteString("\n\n")
        }</span>

        // Instructions
        <span class="cov0" title="0">instructionStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))

        if m.showingSuggestions &amp;&amp; m.addNetworkFocus == 0 </span><span class="cov0" title="0">{
                b.WriteString(instructionStyle.Render("/: Navigate suggestions  Enter: Select  Esc: Close suggestions"))
        }</span> else<span class="cov0" title="0"> {
                b.WriteString(instructionStyle.Render("Tab: Next Field  Enter: Add Network  Esc: Cancel"))
                b.WriteString("\n")
                b.WriteString(instructionStyle.Render(" Tip: Type network name for suggestions or enter Chain ID for auto-completion"))
        }</span>

        <span class="cov0" title="0">return b.String()</span>
}

// renderNetworkDetails renders detailed view of a selected network
func (m Model) renderNetworkDetails() string <span class="cov0" title="0">{
        var b strings.Builder

        headerStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                MarginBottom(2)

        labelStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86"))

        valueStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("240"))

        if m.selectedNetworkKey == "" </span><span class="cov0" title="0">{
                return "No network selected"
        }</span>

        <span class="cov0" title="0">network, exists := m.config.GetNetworkByKey(m.selectedNetworkKey)
        if !exists </span><span class="cov0" title="0">{
                return "Network not found"
        }</span>

        <span class="cov0" title="0">b.WriteString(headerStyle.Render(" Network Details"))
        b.WriteString("\n\n")

        b.WriteString(labelStyle.Render("Name: "))
        b.WriteString(valueStyle.Render(network.Name))
        b.WriteString("\n\n")

        b.WriteString(labelStyle.Render("Chain ID: "))
        b.WriteString(valueStyle.Render(fmt.Sprintf("%d", network.ChainID)))
        b.WriteString("\n\n")

        b.WriteString(labelStyle.Render("Symbol: "))
        b.WriteString(valueStyle.Render(network.Symbol))
        b.WriteString("\n\n")

        b.WriteString(labelStyle.Render("RPC Endpoint: "))
        b.WriteString(valueStyle.Render(network.RPCEndpoint))
        b.WriteString("\n\n")

        b.WriteString(labelStyle.Render("Explorer: "))
        b.WriteString(valueStyle.Render(network.Explorer))
        b.WriteString("\n\n")

        b.WriteString(labelStyle.Render("Status: "))
        status := "Inactive"
        if network.IsActive </span><span class="cov0" title="0">{
                status = "Active"
        }</span>
        <span class="cov0" title="0">b.WriteString(valueStyle.Render(status))
        b.WriteString("\n\n")

        if network.IsCustom </span><span class="cov0" title="0">{
                b.WriteString(labelStyle.Render("Type: "))
                b.WriteString(valueStyle.Render("Custom Network"))
                b.WriteString("\n\n")
        }</span>

        <span class="cov0" title="0">b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("240")).Render("A: Toggle Active  E: Edit  D: Delete (Custom only)  Esc: Back"))

        return b.String()</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package ui

import (
        "blocowallet/internal/blockchain"
        "blocowallet/internal/wallet"
        "blocowallet/pkg/config"
        "context"
        "fmt"
        "log"
        "math"
        "math/big"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
        "github.com/digitallyserviced/tdfgo/tdf"
        zone "github.com/lrstanley/bubblezone"
)

// NewModel creates a new TUI model
func NewModel(walletService *wallet.Service, cfg *config.Config) Model <span class="cov0" title="0">{
        // Initialize text inputs
        nameInput := textinput.New()
        nameInput.Placeholder = "Enter wallet name..."
        nameInput.Width = 40

        passwordInput := textinput.New()
        passwordInput.Placeholder = "Enter password..."
        passwordInput.EchoMode = textinput.EchoPassword
        passwordInput.Width = 40

        mnemonicInput := textinput.New()
        mnemonicInput.Placeholder = "Enter 12-word mnemonic phrase..."
        mnemonicInput.Width = 60

        privateKeyInput := textinput.New()
        privateKeyInput.Placeholder = "Enter private key (without 0x prefix)..."
        privateKeyInput.EchoMode = textinput.EchoPassword
        privateKeyInput.Width = 60

        // Private key password input for viewing keystore keys
        privateKeyPassword := textinput.New()
        privateKeyPassword.Placeholder = "Enter keystore password to view private key..."
        privateKeyPassword.EchoMode = textinput.EchoPassword
        privateKeyPassword.Width = 50

        // Wallet authentication password input for accessing wallet details
        walletAuthPassword := textinput.New()
        walletAuthPassword.Placeholder = "Enter wallet password to access details..."
        walletAuthPassword.EchoMode = textinput.EchoPassword
        walletAuthPassword.Width = 50

        // RPC input
        rpcInput := textinput.New()
        rpcInput.Placeholder = "https://..."
        rpcInput.Width = 60

        // Add network inputs
        networkNameInput := textinput.New()
        networkNameInput.Placeholder = "Enter network name..."
        networkNameInput.Width = 40

        chainIDInput := textinput.New()
        chainIDInput.Placeholder = "Enter chain ID (e.g., 137)..."
        chainIDInput.Width = 40

        rpcEndpointInput := textinput.New()
        rpcEndpointInput.Placeholder = "https://..."
        rpcEndpointInput.Width = 60

        // Preparar items dos menus
        settingsItems := []string{"Network Configuration", "Language", "Back to Main Menu"}

        var networkItems []string
        networkKeys := cfg.GetAllNetworkKeys()
        for _, key := range networkKeys </span><span class="cov0" title="0">{
                if network, exists := cfg.GetNetworkByKey(key); exists </span><span class="cov0" title="0">{
                        status := ""
                        if network.IsActive </span><span class="cov0" title="0">{
                                status = " (Active)"
                        }</span>
                        <span class="cov0" title="0">customTag := ""
                        if network.IsCustom </span><span class="cov0" title="0">{
                                customTag = " [Custom]"
                        }</span>
                        <span class="cov0" title="0">networkItems = append(networkItems, fmt.Sprintf("%s%s%s", network.Name, status, customTag))</span>
                }
        }
        <span class="cov0" title="0">networkItems = append(networkItems, "Add Custom Network", "Back to Settings")

        var languageItems []string
        langCodes := cfg.GetLanguageCodes()
        for _, code := range langCodes </span><span class="cov0" title="0">{
                name := config.SupportedLanguages[code]
                status := ""
                if cfg.Language == code </span><span class="cov0" title="0">{
                        status = " (Current)"
                }</span>
                <span class="cov0" title="0">languageItems = append(languageItems, fmt.Sprintf("%s%s", name, status))</span>
        }
        <span class="cov0" title="0">languageItems = append(languageItems, "Back to Settings")

        // Create the model
        model := Model{
                walletService:       walletService,
                config:              cfg,
                wallets:             []*wallet.Wallet{},
                selected:            0,
                loading:             false,
                currentView:         SplashView,
                nameInput:           nameInput,
                passwordInput:       passwordInput,
                mnemonicInput:       mnemonicInput,
                privateKeyInput:     privateKeyInput,
                privateKeyPassword:  privateKeyPassword,
                extractedPrivateKey: "",
                privateKeyError:     "",
                needsWalletAuth:     false,
                walletAuthPassword:  walletAuthPassword,
                walletAuthError:     "",
                inputFocus:          0,
                rpcInput:            rpcInput,
                networkNameInput:    networkNameInput,
                chainIDInput:        chainIDInput,
                rpcEndpointInput:    rpcEndpointInput,
                addNetworkFocus:     0,
                addingNetwork:       false,
                selectedNetworkKey:  "",
                networkSuggestions:  []blockchain.NetworkSuggestion{},
                showingSuggestions:  false,
                selectedSuggestion:  0,
                chainListService:    blockchain.NewChainListService(),
                settingsSelected:    0,
                networkSelected:     0,
                languageSelected:    0,
                editingRPC:          false,
                settingsItems:       settingsItems,
                networkItems:        networkItems,
                languageItems:       languageItems,
        }

        // Load a default TDF font
        model.loadDefaultFont()

        return model</span>
}

// loadDefaultFont loads a default TDF font for the splash screen
func (m *Model) loadDefaultFont() <span class="cov0" title="0">{
        log.Println("Starting TDF font loading...")

        // Get current working directory
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting cwd: %v", err)
                return
        }</span>
        <span class="cov0" title="0">log.Printf("Current working directory: %s", cwd)

        // Try different possible paths for fonts directory
        fontBasePaths := []string{
                "fonts",                // If running from project root
                "../fonts",             // If running from bin directory
                "../../fonts",          // If running from nested directory
                "~/.blocowallet/fonts", // User's home directory
                filepath.Join(os.Getenv("HOME"), ".blocowallet", "fonts"), // User's home directory
        }

        fontNames := []string{
                "dynasty.tdf",
                "carbonx.tdf",
                "eleuthix.tdf",
                "grandx.tdf",
                "portal.tdf",
        }

        for _, basePath := range fontBasePaths </span><span class="cov0" title="0">{
                for _, fontName := range fontNames </span><span class="cov0" title="0">{
                        fontPath := filepath.Join(basePath, fontName)
                        log.Printf("Attempting to load font: %s", fontPath)

                        // Check if file exists first
                        if _, err := os.Stat(fontPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                                log.Printf("Font file does not exist: %s", fontPath)
                                continue</span>
                        }

                        // Try absolute path as well
                        <span class="cov0" title="0">absPath, _ := filepath.Abs(fontPath)
                        log.Printf("Absolute path: %s", absPath)

                        fontInfo := &amp;tdf.FontInfo{
                                Path:    fontPath,
                                File:    filepath.Base(fontPath),
                                BuiltIn: false,
                        }

                        if fontFile, err := tdf.LoadFont(fontInfo); err == nil &amp;&amp; len(fontFile.Fonts) &gt; 0 </span><span class="cov0" title="0">{
                                m.selectedFont = &amp;fontFile.Fonts[0] // Use the first font in the file
                                m.fontName = filepath.Base(fontPath)
                                log.Printf("Successfully loaded TDF font: %s (contains %d fonts)", fontPath, len(fontFile.Fonts))
                                return
                        }</span> else<span class="cov0" title="0"> {
                                log.Printf("Failed to load font %s: %v", fontPath, err)
                        }</span>
                }
        }

        // If no font loads successfully, selectedFont will remain nil
        // and renderSplash will fall back to text rendering
        <span class="cov0" title="0">log.Println("No TDF fonts could be loaded, using fallback text rendering")</span>
}

// Init initializes the TUI
func (m Model) Init() tea.Cmd <span class="cov0" title="0">{
        // Initialize bubblezone manager for mouse support
        zone.NewGlobal()
        return tea.EnterAltScreen
}</span>

// Update handles user input and state changes
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        // Se h um dilogo de excluso ativo, processar suas mensagens primeiro
        if m.deleteDialog != nil </span><span class="cov0" title="0">{
                if keyMsg, ok := msg.(tea.KeyMsg); ok </span><span class="cov0" title="0">{
                        updatedDialog, cmd := m.deleteDialog.Update(keyMsg)
                        if dialog, ok := updatedDialog.(DeleteWalletDialog); ok </span><span class="cov0" title="0">{
                                m.deleteDialog = &amp;dialog
                        }</span>
                        <span class="cov0" title="0">return m, cmd</span>
                }
                <span class="cov0" title="0">if mouseMsg, ok := msg.(tea.MouseMsg); ok </span><span class="cov0" title="0">{
                        updatedDialog, cmd := m.deleteDialog.Update(mouseMsg)
                        if dialog, ok := updatedDialog.(DeleteWalletDialog); ok </span><span class="cov0" title="0">{
                                m.deleteDialog = &amp;dialog
                        }</span>
                        <span class="cov0" title="0">return m, cmd</span>
                }
                <span class="cov0" title="0">if winMsg, ok := msg.(tea.WindowSizeMsg); ok </span><span class="cov0" title="0">{
                        updatedDialog, _ := m.deleteDialog.Update(winMsg)
                        if dialog, ok := updatedDialog.(DeleteWalletDialog); ok </span><span class="cov0" title="0">{
                                m.deleteDialog = &amp;dialog
                        }</span>
                }
        }

        <span class="cov0" title="0">switch msg := msg.(type) </span>{
        case tea.MouseMsg:<span class="cov0" title="0">
                // Update bubblezone with mouse events
                return zone.AnyInBoundsAndUpdate(m, msg)</span>

        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.width = msg.Width
                m.height = msg.Height
                return m, nil</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                return m.handleKeyMsg(msg)</span>

        case walletsLoadedMsg:<span class="cov0" title="0">
                m.wallets = []*wallet.Wallet(msg)
                m.loading = false
                m.err = nil
                return m, nil</span>

        case balanceLoadedMsg:<span class="cov0" title="0">
                m.currentBalance = (*wallet.Balance)(msg)
                return m, nil</span>

        case multiBalanceLoadedMsg:<span class="cov0" title="0">
                m.currentMultiBalance = (*wallet.MultiNetworkBalance)(msg)
                return m, nil</span>

        case walletCreatedMsg:<span class="cov0" title="0">
                newModel := m
                newModel.currentView = WalletListView
                newModel.selected = 0
                // Reset inputs manually
                newModel.nameInput.SetValue("")
                newModel.passwordInput.SetValue("")
                newModel.mnemonicInput.SetValue("")
                newModel.privateKeyInput.SetValue("")
                newModel.inputFocus = 0
                newModel.nameInput.Blur()
                newModel.passwordInput.Blur()
                newModel.mnemonicInput.Blur()
                newModel.privateKeyInput.Blur()
                return newModel, newModel.loadWalletsCmd()</span>

        case errorMsg:<span class="cov0" title="0">
                m.err = fmt.Errorf("%s", string(msg))
                m.loading = false
                return m, nil</span>

        case networkSuggestionsMsg:<span class="cov0" title="0">
                m.networkSuggestions = []blockchain.NetworkSuggestion(msg)
                m.showingSuggestions = len(m.networkSuggestions) &gt; 0
                m.selectedSuggestion = 0
                return m, nil</span>

        case chainInfoLoadedMsg:<span class="cov0" title="0">
                // Auto-fill fields when chain info is loaded by Chain ID
                chainInfo := msg.chainInfo
                if chainInfo != nil </span><span class="cov0" title="0">{
                        // Fill network name if empty
                        if strings.TrimSpace(m.networkNameInput.Value()) == "" </span><span class="cov0" title="0">{
                                m.networkNameInput.SetValue(chainInfo.Name)
                        }</span>
                        // Fill RPC endpoint if empty
                        <span class="cov0" title="0">if strings.TrimSpace(m.rpcEndpointInput.Value()) == "" </span><span class="cov0" title="0">{
                                m.rpcEndpointInput.SetValue(msg.rpcURL)
                        }</span>
                }
                <span class="cov0" title="0">return m, nil</span>

        case ConfirmDeleteMsg:<span class="cov0" title="0">
                // Confirmar a excluso da wallet
                if m.deleteDialog != nil &amp;&amp; m.selectedWallet != nil </span><span class="cov0" title="0">{
                        if err := m.walletService.DeleteWalletByAddress(context.Background(), m.selectedWallet.Address); err != nil </span><span class="cov0" title="0">{
                                m.err = fmt.Errorf("failed to delete wallet: %w", err)
                        }</span> else<span class="cov0" title="0"> {
                                // Reset state and go back to wallet list
                                m.currentView = WalletListView
                                m.selectedWallet = nil
                                m.deleteDialog = nil
                                m.showSensitiveInfo = false
                                m.extractedPrivateKey = ""
                                // Reload wallets
                                return m, tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                                        wallets, err := m.walletService.GetAllWallets(context.Background())
                                        if err != nil </span><span class="cov0" title="0">{
                                                return errorMsg(err.Error())
                                        }</span>
                                        <span class="cov0" title="0">return walletsLoadedMsg(wallets)</span>
                                })
                        }
                }
                <span class="cov0" title="0">return m, nil</span>

        case CancelDeleteMsg:<span class="cov0" title="0">
                // Cancelar a excluso da wallet
                m.deleteDialog = nil
                return m, nil</span>

        case networkAddedMsg:<span class="cov0" title="0">
                // Add the custom network to config
                m.config.AddCustomNetwork(msg.key, msg.network)
                if err := m.config.Save(); err != nil </span><span class="cov0" title="0">{
                        m.err = err
                }</span> else<span class="cov0" title="0"> {
                        // Refresh network items and go back to network config
                        m.refreshNetworkItems()
                        m.currentView = NetworkConfigView
                        m.networkSelected = 0
                        m.addingNetwork = false
                        // Reset inputs
                        m.networkNameInput.SetValue("")
                        m.chainIDInput.SetValue("")
                        m.rpcEndpointInput.SetValue("")
                        m.addNetworkFocus = 0
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        case networkErrorMsg:<span class="cov0" title="0">
                m.err = fmt.Errorf("%s", string(msg))
                m.addingNetwork = false
                return m, nil</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// handleKeyMsg handles keyboard input
func (m Model) handleKeyMsg(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        // Handle input fields in create/import views, RPC editing, wallet auth, and add network
        if m.currentView == CreateWalletView || m.currentView == ImportWalletView || m.currentView == ImportPrivateKeyView ||
                m.currentView == WalletAuthView ||
                (m.currentView == NetworkConfigView &amp;&amp; m.editingRPC) ||
                (m.currentView == AddNetworkView &amp;&amp; !m.addingNetwork) </span><span class="cov0" title="0">{
                switch msg.String() </span>{
                case "esc":<span class="cov0" title="0">
                        newModel := m
                        if newModel.currentView == NetworkConfigView &amp;&amp; newModel.editingRPC </span><span class="cov0" title="0">{
                                // Cancel RPC editing
                                newModel.editingRPC = false
                                newModel.rpcInput.Blur()
                                return newModel, nil
                        }</span> else<span class="cov0" title="0"> if newModel.currentView == WalletAuthView </span><span class="cov0" title="0">{
                                // Cancel wallet authentication and go back to wallet list
                                newModel.currentView = WalletListView
                                newModel.needsWalletAuth = false
                                newModel.walletAuthPassword.SetValue("")
                                newModel.walletAuthPassword.Blur()
                                newModel.walletAuthError = ""
                                newModel.selectedWallet = nil
                                return newModel, nil
                        }</span>
                        <span class="cov0" title="0">newModel.currentView = MenuView
                        newModel.selected = 0
                        // Reset inputs manually instead of calling resetInputs
                        newModel.nameInput.SetValue("")
                        newModel.passwordInput.SetValue("")
                        newModel.mnemonicInput.SetValue("")
                        newModel.privateKeyInput.SetValue("")
                        newModel.inputFocus = 0
                        newModel.nameInput.Blur()
                        newModel.passwordInput.Blur()
                        newModel.mnemonicInput.Blur()
                        newModel.privateKeyInput.Blur()
                        return newModel, nil</span>
                case "tab", "shift+tab", "up", "down":<span class="cov0" title="0">
                        if m.currentView == AddNetworkView </span><span class="cov0" title="0">{
                                return m.handleAddNetworkNavigation(msg)
                        }</span>
                        <span class="cov0" title="0">return m.handleInputNavigation(msg)</span>
                case "enter":<span class="cov0" title="0">
                        if m.currentView == NetworkConfigView &amp;&amp; m.editingRPC </span><span class="cov0" title="0">{
                                // Save RPC endpoint
                                networkKeys := m.config.GetAllNetworkKeys()
                                if m.networkSelected &lt; len(networkKeys) </span><span class="cov0" title="0">{
                                        key := networkKeys[m.networkSelected]
                                        if network, exists := m.config.GetNetworkByKey(key); exists </span><span class="cov0" title="0">{
                                                network.RPCEndpoint = strings.TrimSpace(m.rpcInput.Value())
                                                if network.IsCustom </span><span class="cov0" title="0">{
                                                        m.config.CustomNetworks[key] = network
                                                }</span> else<span class="cov0" title="0"> {
                                                        m.config.Networks[key] = network
                                                }</span>
                                                // Save configuration to file
                                                <span class="cov0" title="0">_ = m.config.Save()</span>
                                        }
                                }
                                <span class="cov0" title="0">m.editingRPC = false
                                m.rpcInput.Blur()
                                return m, nil</span>
                        } else<span class="cov0" title="0"> if m.currentView == AddNetworkView </span><span class="cov0" title="0">{
                                // Check if we're showing suggestions first
                                if m.showingSuggestions &amp;&amp; m.addNetworkFocus == 0 </span><span class="cov0" title="0">{
                                        // Handle suggestion selection
                                        return m.handleAddNetworkNavigation(msg)
                                }</span>
                                // Otherwise handle form submission
                                <span class="cov0" title="0">return m.handleAddNetworkSubmit()</span>
                        } else<span class="cov0" title="0"> if m.currentView == WalletAuthView </span><span class="cov0" title="0">{
                                // Handle wallet authentication
                                return m.handleInputSubmit()
                        }</span>
                        <span class="cov0" title="0">return m.handleInputSubmit()</span>
                default:<span class="cov0" title="0">
                        // Update the focused input field with the key
                        newModel := m
                        var cmd tea.Cmd

                        if newModel.currentView == NetworkConfigView &amp;&amp; newModel.editingRPC </span><span class="cov0" title="0">{
                                // Handle RPC input
                                newModel.rpcInput, cmd = newModel.rpcInput.Update(msg)
                        }</span> else<span class="cov0" title="0"> if newModel.currentView == AddNetworkView </span><span class="cov0" title="0">{
                                // Handle add network inputs
                                switch newModel.addNetworkFocus </span>{
                                case 0:<span class="cov0" title="0">
                                        oldValue := newModel.networkNameInput.Value()
                                        newModel.networkNameInput, cmd = newModel.networkNameInput.Update(msg)
                                        newValue := newModel.networkNameInput.Value()

                                        // Trigger search if value changed and has at least 2 characters
                                        if oldValue != newValue &amp;&amp; len(strings.TrimSpace(newValue)) &gt;= 2 </span><span class="cov0" title="0">{
                                                return newModel, tea.Batch(cmd, newModel.searchNetworksCmd(newValue))
                                        }</span>

                                        // Hide suggestions if input is too short
                                        <span class="cov0" title="0">if len(strings.TrimSpace(newValue)) &lt; 2 </span><span class="cov0" title="0">{
                                                newModel.showingSuggestions = false
                                                newModel.networkSuggestions = []blockchain.NetworkSuggestion{}
                                        }</span>
                                case 1:<span class="cov0" title="0">
                                        oldValue := newModel.chainIDInput.Value()
                                        newModel.chainIDInput, cmd = newModel.chainIDInput.Update(msg)
                                        newValue := newModel.chainIDInput.Value()

                                        // Auto-load chain info when Chain ID is entered
                                        if oldValue != newValue &amp;&amp; strings.TrimSpace(newValue) != "" </span><span class="cov0" title="0">{
                                                if chainID, err := strconv.Atoi(strings.TrimSpace(newValue)); err == nil </span><span class="cov0" title="0">{
                                                        return newModel, tea.Batch(cmd, newModel.loadChainInfoByIDCmd(chainID))
                                                }</span>
                                        }
                                case 2:<span class="cov0" title="0">
                                        newModel.rpcEndpointInput, cmd = newModel.rpcEndpointInput.Update(msg)</span>
                                }
                        } else<span class="cov0" title="0"> if newModel.currentView == WalletAuthView </span><span class="cov0" title="0">{
                                // Handle wallet authentication password input
                                newModel.walletAuthPassword, cmd = newModel.walletAuthPassword.Update(msg)
                        }</span> else<span class="cov0" title="0"> {
                                switch newModel.inputFocus </span>{
                                case 0:<span class="cov0" title="0"> // Name input
                                        newModel.nameInput, cmd = newModel.nameInput.Update(msg)</span>
                                case 1:<span class="cov0" title="0"> // Password input
                                        newModel.passwordInput, cmd = newModel.passwordInput.Update(msg)</span>
                                case 2:<span class="cov0" title="0"> // Mnemonic input (only in import view) or Private Key input (only in import private key view)
                                        if newModel.currentView == ImportWalletView </span><span class="cov0" title="0">{
                                                newModel.mnemonicInput, cmd = newModel.mnemonicInput.Update(msg)
                                        }</span> else<span class="cov0" title="0"> if newModel.currentView == ImportPrivateKeyView </span><span class="cov0" title="0">{
                                                newModel.privateKeyInput, cmd = newModel.privateKeyInput.Update(msg)
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">return newModel, cmd</span>
                }
        }

        // Regular navigation for other views
        <span class="cov0" title="0">switch msg.String() </span>{
        case "ctrl+c", "q":<span class="cov0" title="0">
                return m, tea.Quit</span>

        case "esc":<span class="cov0" title="0">
                switch m.currentView </span>{
                case WalletAuthView:<span class="cov0" title="0">
                        m.currentView = WalletListView
                        m.needsWalletAuth = false
                        m.walletAuthPassword.Reset()
                        m.walletAuthError = ""</span>
                case WalletDetailsView:<span class="cov0" title="0">
                        m.currentView = WalletListView</span>
                case CreateWalletView, ImportWalletView, ImportPrivateKeyView:<span class="cov0" title="0">
                        m.currentView = MenuView
                        m.selected = 0
                        m.resetInputs()</span>
                case SettingsView:<span class="cov0" title="0">
                        m.currentView = MenuView
                        m.selected = 0</span>
                case NetworkConfigView, LanguageView:<span class="cov0" title="0">
                        m.currentView = SettingsView
                        m.settingsSelected = 0</span>
                case AddNetworkView:<span class="cov0" title="0">
                        m.currentView = NetworkConfigView
                        m.networkSelected = 0
                        m.addingNetwork = false
                        // Reset inputs
                        m.networkNameInput.SetValue("")
                        m.chainIDInput.SetValue("")
                        m.rpcEndpointInput.SetValue("")
                        m.addNetworkFocus = 0</span>
                case NetworkDetailsView:<span class="cov0" title="0">
                        m.currentView = NetworkConfigView
                        m.networkSelected = 0</span>
                case MenuView:<span class="cov0" title="0">
                        m.currentView = SplashView</span>
                case WalletListView:<span class="cov0" title="0">
                        m.currentView = MenuView
                        m.selected = 0</span>
                }
                <span class="cov0" title="0">return m, nil</span>

        case " ", "enter":<span class="cov0" title="0">
                return m.handleEnterKey()</span>

        case "up", "k":<span class="cov0" title="0">
                if m.currentView == MenuView </span><span class="cov0" title="0">{
                        if m.selected &gt; 0 </span><span class="cov0" title="0">{
                                m.selected--
                        }</span>
                } else<span class="cov0" title="0"> if m.currentView == WalletListView </span><span class="cov0" title="0">{
                        if m.selected &gt; 0 </span><span class="cov0" title="0">{
                                m.selected--
                        }</span>
                } else<span class="cov0" title="0"> if m.currentView == SettingsView </span><span class="cov0" title="0">{
                        if m.settingsSelected &gt; 0 </span><span class="cov0" title="0">{
                                m.settingsSelected--
                        }</span>
                } else<span class="cov0" title="0"> if m.currentView == NetworkConfigView </span><span class="cov0" title="0">{
                        if !m.editingRPC &amp;&amp; m.networkSelected &gt; 0 </span><span class="cov0" title="0">{
                                m.networkSelected--
                        }</span>
                } else<span class="cov0" title="0"> if m.currentView == LanguageView </span><span class="cov0" title="0">{
                        if m.languageSelected &gt; 0 </span><span class="cov0" title="0">{
                                m.languageSelected--
                        }</span>
                } else<span class="cov0" title="0"> if m.currentView == AddNetworkView </span><span class="cov0" title="0">{
                        if !m.addingNetwork &amp;&amp; m.addNetworkFocus &gt; 0 </span><span class="cov0" title="0">{
                                m.addNetworkFocus--
                                m.updateAddNetworkFocus()
                        }</span>
                }
                <span class="cov0" title="0">return m, nil</span>

        case "down", "j":<span class="cov0" title="0">
                maxItems := 0
                if m.currentView == MenuView </span><span class="cov0" title="0">{
                        maxItems = 5 // 6 menu items (0-5)
                }</span> else<span class="cov0" title="0"> if m.currentView == WalletListView </span><span class="cov0" title="0">{
                        maxItems = len(m.wallets) - 1
                }</span> else<span class="cov0" title="0"> if m.currentView == SettingsView </span><span class="cov0" title="0">{
                        maxItems = len(m.settingsItems) - 1
                }</span> else<span class="cov0" title="0"> if m.currentView == NetworkConfigView </span><span class="cov0" title="0">{
                        if !m.editingRPC </span><span class="cov0" title="0">{
                                maxItems = len(m.networkItems) - 1
                        }</span>
                } else<span class="cov0" title="0"> if m.currentView == LanguageView </span><span class="cov0" title="0">{
                        maxItems = len(m.languageItems) - 1
                }</span> else<span class="cov0" title="0"> if m.currentView == AddNetworkView </span><span class="cov0" title="0">{
                        maxItems = 2 // 3 input fields (0-2)
                }</span>

                <span class="cov0" title="0">if m.currentView == SettingsView &amp;&amp; m.settingsSelected &lt; maxItems </span><span class="cov0" title="0">{
                        m.settingsSelected++
                }</span> else<span class="cov0" title="0"> if m.currentView == NetworkConfigView &amp;&amp; !m.editingRPC &amp;&amp; m.networkSelected &lt; maxItems </span><span class="cov0" title="0">{
                        m.networkSelected++
                }</span> else<span class="cov0" title="0"> if m.currentView == LanguageView &amp;&amp; m.languageSelected &lt; maxItems </span><span class="cov0" title="0">{
                        m.languageSelected++
                }</span> else<span class="cov0" title="0"> if m.currentView == AddNetworkView &amp;&amp; !m.addingNetwork &amp;&amp; m.addNetworkFocus &lt; maxItems </span><span class="cov0" title="0">{
                        m.addNetworkFocus++
                        m.updateAddNetworkFocus()
                }</span> else<span class="cov0" title="0"> if m.selected &lt; maxItems </span><span class="cov0" title="0">{
                        m.selected++
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        case "a", "A":<span class="cov0" title="0">
                // Toggle network active/inactive status (allows multiple active networks)
                if m.currentView == NetworkConfigView &amp;&amp; !m.editingRPC </span><span class="cov0" title="0">{
                        networkKeys := m.config.GetAllNetworkKeys()
                        if m.networkSelected &lt; len(networkKeys) </span><span class="cov0" title="0">{
                                key := networkKeys[m.networkSelected]

                                // Toggle network active status
                                err := m.config.ToggleNetworkActive(key)
                                if err == nil </span><span class="cov0" title="0">{
                                        // Refresh network items to show updated status
                                        m.refreshNetworkItems()

                                        // Refresh multi-provider with updated network configuration
                                        m.walletService.RefreshMultiProvider(m.config)

                                        // Save configuration
                                        _ = m.config.Save()
                                }</span>
                        }
                }
                <span class="cov0" title="0">return m, nil</span>

        case "e", "E":<span class="cov0" title="0">
                // Edit RPC endpoint
                if m.currentView == NetworkConfigView &amp;&amp; !m.editingRPC </span><span class="cov0" title="0">{
                        networkKeys := m.config.GetAllNetworkKeys()
                        if m.networkSelected &lt; len(networkKeys) </span><span class="cov0" title="0">{
                                key := networkKeys[m.networkSelected]
                                if network, exists := m.config.GetNetworkByKey(key); exists </span><span class="cov0" title="0">{
                                        m.editingRPC = true
                                        m.rpcInput.Focus()
                                        m.rpcInput.SetValue(network.RPCEndpoint)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return m, nil</span>

        case "s":<span class="cov0" title="0">
                if m.currentView == WalletDetailsView &amp;&amp; m.selectedWallet != nil </span><span class="cov0" title="0">{
                        // Toggle sensitive information visibility
                        newModel := m
                        newModel.showSensitiveInfo = !newModel.showSensitiveInfo
                        return newModel, nil
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        case "d":<span class="cov0" title="0">
                if m.currentView == WalletDetailsView &amp;&amp; m.selectedWallet != nil </span><span class="cov0" title="0">{
                        // Criar o dilogo de excluso
                        if m.deleteDialog == nil </span><span class="cov0" title="0">{
                                dialog := NewDeleteWalletDialog(m.selectedWallet.Name, m.selectedWallet.Address)
                                m.deleteDialog = &amp;dialog
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>
                }
                <span class="cov0" title="0">return m, nil</span>

        case "y":<span class="cov0" title="0">
                // A lgica de confirmao de excluso agora  feita pelo dilogo
                return m, nil</span>

        case "n":<span class="cov0" title="0">
                // A lgica de cancelamento agora  feita pelo dilogo
                return m, nil</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// handleInputNavigation handles navigation between input fields
// View renders the TUI
func (m Model) View() string <span class="cov0" title="0">{
        if m.width == 0 </span><span class="cov0" title="0">{
                return "Loading..."
        }</span>

        <span class="cov0" title="0">var baseView string
        switch m.currentView </span>{
        case SplashView:<span class="cov0" title="0">
                baseView = m.renderSplash()</span>
        case MenuView:<span class="cov0" title="0">
                baseView = m.renderMenu()</span>
        case WalletListView:<span class="cov0" title="0">
                baseView = m.renderWalletList()</span>
        case WalletAuthView:<span class="cov0" title="0">
                baseView = m.renderWalletAuth()</span>
        case WalletDetailsView:<span class="cov0" title="0">
                baseView = m.renderWalletDetails()</span>
        case CreateWalletView:<span class="cov0" title="0">
                baseView = m.renderCreateWallet()</span>
        case ImportWalletView:<span class="cov0" title="0">
                baseView = m.renderImportWallet()</span>
        case ImportPrivateKeyView:<span class="cov0" title="0">
                baseView = m.renderImportPrivateKey()</span>
        case SettingsView:<span class="cov0" title="0">
                baseView = m.renderSettings()</span>
        case NetworkConfigView:<span class="cov0" title="0">
                baseView = m.renderNetworkConfig()</span>
        case LanguageView:<span class="cov0" title="0">
                baseView = m.renderLanguage()</span>
        case AddNetworkView:<span class="cov0" title="0">
                baseView = m.renderAddNetwork()</span>
        case NetworkDetailsView:<span class="cov0" title="0">
                baseView = m.renderNetworkDetails()</span>
        default:<span class="cov0" title="0">
                baseView = m.renderWalletList()</span>
        }

        // Se h um dilogo de excluso ativo, renderiz-lo sobre a view base
        <span class="cov0" title="0">if m.deleteDialog != nil </span><span class="cov0" title="0">{
                dialog := m.deleteDialog.View()

                // Centralizar o dilogo
                centeredDialog := lipgloss.Place(
                        m.width, m.height,
                        lipgloss.Center, lipgloss.Center,
                        dialog,
                )

                return centeredDialog
        }</span>

        <span class="cov0" title="0">return baseView</span>
}

// Render methods
func (m Model) renderSplash() string <span class="cov0" title="0">{
        // Check if TDF font is available
        if m.selectedFont != nil </span><span class="cov0" title="0">{
                // Initialize string renderer for the selected font
                fontString := tdf.NewTheDrawFontStringFont(m.selectedFont)

                // Render the "bloco" logo using TDF font
                renderedLogo := fontString.RenderString("bloco")
                renderedLogo = strings.TrimSpace(renderedLogo)

                // Project info
                projectInfo := fmt.Sprintf("%s v%s", "BLOCO Wallet Manager", "1.0.0")

                // Center the project info text
                projectInfoStyled := lipgloss.NewStyle().
                        Align(lipgloss.Center).
                        Foreground(lipgloss.Color("86")).
                        Render(projectInfo)

                // Create the splash screen content
                splashContent := lipgloss.JoinVertical(
                        lipgloss.Center,
                        renderedLogo,
                        "",
                        projectInfoStyled,
                        "",
                        lipgloss.NewStyle().
                                Foreground(lipgloss.Color("241")).
                                Align(lipgloss.Center).
                                Render("Press any key to continue..."),
                )

                // Use lipgloss.Place to center horizontally and vertically
                finalSplash := lipgloss.Place(
                        m.width,
                        m.height,
                        lipgloss.Center,
                        lipgloss.Center,
                        splashContent,
                )

                return finalSplash
        }</span>

        // Fallback to original text-based splash if no TDF font is available
        <span class="cov0" title="0">var b strings.Builder

        logoStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                Align(lipgloss.Center).
                Width(m.width).
                MarginTop(m.height / 4)

        b.WriteString(logoStyle.Render(" BlocoWallet"))
        b.WriteString("\n\n")

        subtitleStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("241")).
                Align(lipgloss.Center).
                Width(m.width)

        b.WriteString(subtitleStyle.Render("Your Ethereum Wallet Manager"))
        b.WriteString("\n\n")

        instructionStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("86")).
                Align(lipgloss.Center).
                Width(m.width)

        b.WriteString(instructionStyle.Render("Press any key to continue..."))

        return b.String()</span>
}

func (m Model) renderMenu() string <span class="cov0" title="0">{
        var b strings.Builder

        headerStyle := HeaderStyle

        b.WriteString(headerStyle.Render(" BlocoWallet - Main Menu"))
        b.WriteString("\n\n")

        menuItems := []string{
                " View Wallets",
                " Create New Wallet",
                " Import Wallet (Mnemonic)",
                " Import Wallet (Private Key)",
                "  Settings",
                " Exit",
        }

        for i, item := range menuItems </span><span class="cov0" title="0">{
                if i == m.selected </span><span class="cov0" title="0">{
                        selectedStyle := lipgloss.NewStyle().
                                Background(lipgloss.Color("86")).
                                Foreground(lipgloss.Color("232")).
                                Padding(0, 1)
                        b.WriteString(selectedStyle.Render(" " + item))
                }</span> else<span class="cov0" title="0"> {
                        b.WriteString("  " + item)
                }</span>
                <span class="cov0" title="0">b.WriteString("\n")</span>
        }

        <span class="cov0" title="0">b.WriteString("\n")
        footerStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("241"))
        b.WriteString(footerStyle.Render("/: navigate  enter: select  q: quit"))

        return b.String()</span>
}

func (m Model) renderWalletList() string <span class="cov0" title="0">{
        var b strings.Builder

        headerStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                MarginBottom(2)

        b.WriteString(headerStyle.Render(" Your Wallets"))
        b.WriteString("\n\n")

        if m.loading </span><span class="cov0" title="0">{
                b.WriteString("Loading wallets...")
                return b.String()
        }</span>

        <span class="cov0" title="0">if len(m.wallets) == 0 </span><span class="cov0" title="0">{
                b.WriteString("No wallets found. Create a new wallet to get started.\n\n")
        }</span> else<span class="cov0" title="0"> {
                for i, wallet := range m.wallets </span><span class="cov0" title="0">{
                        if i == m.selected </span><span class="cov0" title="0">{
                                selectedStyle := lipgloss.NewStyle().
                                        Background(lipgloss.Color("86")).
                                        Foreground(lipgloss.Color("232")).
                                        Padding(0, 1)
                                b.WriteString(selectedStyle.Render(fmt.Sprintf(" %s (%s)", wallet.Name, wallet.Address[:10]+"...")))
                        }</span> else<span class="cov0" title="0"> {
                                b.WriteString(fmt.Sprintf("  %s (%s)", wallet.Name, wallet.Address[:10]+"..."))
                        }</span>
                        <span class="cov0" title="0">b.WriteString("\n")</span>
                }
                <span class="cov0" title="0">b.WriteString("\n")</span>
        }

        <span class="cov0" title="0">if m.err != nil </span><span class="cov0" title="0">{
                errorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("196"))
                b.WriteString(errorStyle.Render("Error: " + m.err.Error()))
                b.WriteString("\n\n")
        }</span>

        <span class="cov0" title="0">footerStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("241"))
        b.WriteString(footerStyle.Render("/: navigate  enter: view details  r: refresh  esc: back  q: quit"))

        return b.String()</span>
}

func (m Model) renderWalletAuth() string <span class="cov0" title="0">{
        var b strings.Builder

        headerStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                MarginBottom(2)

        b.WriteString(headerStyle.Render(" Wallet Authentication"))
        b.WriteString("\n\n")

        if m.selectedWallet != nil </span><span class="cov0" title="0">{
                infoStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("240"))

                b.WriteString(infoStyle.Render(fmt.Sprintf("Wallet: %s", m.selectedWallet.Name)))
                b.WriteString("\n")
                b.WriteString(infoStyle.Render(fmt.Sprintf("Address: %s", m.selectedWallet.Address)))
                b.WriteString("\n\n")
        }</span>

        <span class="cov0" title="0">b.WriteString("Enter wallet password to access details:\n\n")

        // Password input
        b.WriteString("Password:\n")
        b.WriteString(m.walletAuthPassword.View())
        b.WriteString("\n\n")

        // Show error if any
        if m.walletAuthError != "" </span><span class="cov0" title="0">{
                errorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("196"))
                b.WriteString(errorStyle.Render(" " + m.walletAuthError))
                b.WriteString("\n\n")
        }</span>

        <span class="cov0" title="0">footerStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("241"))
        b.WriteString(footerStyle.Render("enter: authenticate  esc: back  q: quit"))

        return b.String()</span>
}

func (m Model) renderWalletDetails() string <span class="cov0" title="0">{
        var b strings.Builder

        headerStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                MarginBottom(2)

        if m.selectedWallet == nil </span><span class="cov0" title="0">{
                b.WriteString(headerStyle.Render(" Wallet Details"))
                b.WriteString("\n\nNo wallet selected.")
                return b.String()
        }</span>

        <span class="cov0" title="0">b.WriteString(headerStyle.Render(" " + m.selectedWallet.Name))
        b.WriteString("\n\n")

        info := fmt.Sprintf("Address: %s\nCreated: %s",
                m.selectedWallet.Address,
                m.selectedWallet.CreatedAt.Format("2006-01-02 15:04:05"))

        b.WriteString(info)
        b.WriteString("\n\n")

        // Add sensitive information section
        sensitiveStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("208")).
                Bold(true)

        b.WriteString(sensitiveStyle.Render(" Sensitive Information:"))
        b.WriteString("\n")

        // Private Key
        if m.showSensitiveInfo </span><span class="cov0" title="0">{
                if m.selectedWallet.EncryptedMnemonic != "" </span><span class="cov0" title="0">{
                        // Get cached password for this wallet
                        password, hasPassword := m.walletService.GetWalletPassword(m.selectedWallet.Address)
                        if hasPassword </span><span class="cov0" title="0">{
                                // Decrypt mnemonic and derive private key
                                mnemonic, err := m.walletService.GetMnemonicFromWallet(m.selectedWallet, password)
                                if err != nil </span><span class="cov0" title="0">{
                                        b.WriteString(fmt.Sprintf("Private Key: Error decrypting mnemonic - %v\n", err))
                                }</span> else<span class="cov0" title="0"> {
                                        privateKey, err := wallet.DerivePrivateKey(mnemonic)
                                        if err != nil </span><span class="cov0" title="0">{
                                                b.WriteString(fmt.Sprintf("Private Key: Error deriving key - %v\n", err))
                                        }</span> else<span class="cov0" title="0"> {
                                                b.WriteString(fmt.Sprintf("Private Key: %s\n", privateKey))
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                b.WriteString("Private Key: Authentication required\n")
                        }</span>
                } else<span class="cov0" title="0"> if m.selectedWallet.KeyStorePath != "" </span><span class="cov0" title="0">{
                        // Handle keystore-based wallets (both mnemonic-based and private key imports)
                        if m.extractedPrivateKey != "" </span><span class="cov0" title="0">{
                                // Private key has been successfully extracted
                                b.WriteString(fmt.Sprintf("Private Key: %s\n", m.extractedPrivateKey))
                        }</span> else<span class="cov0" title="0"> {
                                // Try to extract using cached password
                                if cachedPassword, hasPassword := m.walletService.GetWalletPassword(m.selectedWallet.Address); hasPassword </span><span class="cov0" title="0">{
                                        privateKey, err := m.walletService.LoadPrivateKeyFromKeyStoreV3(m.selectedWallet.KeyStorePath, cachedPassword)
                                        if err != nil </span><span class="cov0" title="0">{
                                                b.WriteString(fmt.Sprintf("Private Key: Error - %s\n", err.Error()))
                                        }</span> else<span class="cov0" title="0"> {
                                                // Cache the extracted private key for subsequent renders
                                                privateKeyHex := fmt.Sprintf("%x", privateKey.D.Bytes())
                                                m.extractedPrivateKey = privateKeyHex
                                                b.WriteString(fmt.Sprintf("Private Key: %s\n", privateKeyHex))
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // This shouldn't happen since we require auth before entering details
                                        b.WriteString("Private Key: Authentication required\n")
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Neither mnemonic nor keystore path available - this should be rare
                        b.WriteString("Private Key: Not available (no keystore or mnemonic found)\n")
                }</span>
        } else<span class="cov0" title="0"> {
                b.WriteString("Private Key: ********************************\n")
        }</span>

        // Mnemonic
        <span class="cov0" title="0">if m.showSensitiveInfo </span><span class="cov0" title="0">{
                if m.selectedWallet.EncryptedMnemonic != "" </span><span class="cov0" title="0">{
                        // Get cached password for this wallet
                        password, hasPassword := m.walletService.GetWalletPassword(m.selectedWallet.Address)
                        if hasPassword </span><span class="cov0" title="0">{
                                // Decrypt mnemonic
                                mnemonic, err := m.walletService.GetMnemonicFromWallet(m.selectedWallet, password)
                                if err != nil </span><span class="cov0" title="0">{
                                        b.WriteString(fmt.Sprintf("Mnemonic: Error decrypting - %v\n", err))
                                }</span> else<span class="cov0" title="0"> {
                                        b.WriteString(fmt.Sprintf("Mnemonic: %s\n", mnemonic))
                                }</span>
                        } else<span class="cov0" title="0"> {
                                b.WriteString("Mnemonic: Authentication required\n")
                        }</span>
                } else<span class="cov0" title="0"> {
                        b.WriteString("Mnemonic: Not available (imported from private key)\n")
                }</span>
        } else<span class="cov0" title="0"> {
                b.WriteString("Mnemonic: *** *** *** *** *** *** *** *** *** *** *** ***\n")
        }</span>

        <span class="cov0" title="0">b.WriteString("\n")

        // Render multi-network balances
        if m.currentMultiBalance != nil </span><span class="cov0" title="0">{
                balanceStyle := lipgloss.NewStyle().
                        Bold(true).
                        Foreground(lipgloss.Color("86"))

                networkStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("240"))

                errorStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("196"))

                b.WriteString(balanceStyle.Render(" Network Balances:"))
                b.WriteString("\n\n")

                for _, networkBalance := range m.currentMultiBalance.NetworkBalances </span><span class="cov0" title="0">{
                        if networkBalance.Error != nil </span><span class="cov0" title="0">{
                                b.WriteString(networkStyle.Render(fmt.Sprintf("  %s: ", networkBalance.NetworkName)))
                                b.WriteString(errorStyle.Render(fmt.Sprintf("Error - %v", networkBalance.Error)))
                        }</span> else<span class="cov0" title="0"> {
                                // Convert wei to ether for display
                                balanceFloat := new(big.Float).SetInt(networkBalance.Amount)
                                divisor := new(big.Float).SetFloat64(math.Pow(10, float64(networkBalance.Decimals)))
                                balanceFloat.Quo(balanceFloat, divisor)

                                balanceStr := balanceFloat.Text('f', 6)
                                // Remove trailing zeros
                                balanceStr = strings.TrimRight(balanceStr, "0")
                                balanceStr = strings.TrimRight(balanceStr, ".")

                                b.WriteString(networkStyle.Render(fmt.Sprintf("  %s: ", networkBalance.NetworkName)))
                                b.WriteString(fmt.Sprintf("%s %s", balanceStr, networkBalance.Symbol))
                        }</span>
                        <span class="cov0" title="0">b.WriteString("\n")</span>
                }

                <span class="cov0" title="0">updateTime := m.currentMultiBalance.UpdatedAt.Format("2006-01-02 15:04:05")
                b.WriteString("\n")
                b.WriteString(networkStyle.Render(fmt.Sprintf("Last updated: %s", updateTime)))</span>
        } else<span class="cov0" title="0"> {
                b.WriteString("Balance: Loading...")
        }</span>

        <span class="cov0" title="0">b.WriteString("\n\n")

        if m.err != nil </span><span class="cov0" title="0">{
                errorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("196"))
                b.WriteString(errorStyle.Render("Error: " + m.err.Error()))
                b.WriteString("\n\n")
        }</span>

        <span class="cov0" title="0">footerStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("241"))
        if m.showSensitiveInfo </span><span class="cov0" title="0">{
                b.WriteString(footerStyle.Render("r: refresh balance  s: hide sensitive info  d: delete wallet  esc: back  q: quit"))
        }</span> else<span class="cov0" title="0"> {
                b.WriteString(footerStyle.Render("r: refresh balance  s: show sensitive info  d: delete wallet  esc: back  q: quit"))
        }</span>

        <span class="cov0" title="0">return b.String()</span>
}

func (m Model) renderCreateWallet() string <span class="cov0" title="0">{
        var b strings.Builder

        headerStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                MarginBottom(2)

        b.WriteString(headerStyle.Render(" Create New Wallet"))
        b.WriteString("\n\n")

        b.WriteString("Fill in the details to create a new wallet:\n\n")

        // Name input
        b.WriteString("Wallet Name:\n")
        b.WriteString(m.nameInput.View())
        b.WriteString("\n\n")

        // Password input
        b.WriteString("Password:\n")
        b.WriteString(m.passwordInput.View())
        b.WriteString("\n\n")

        if m.err != nil </span><span class="cov0" title="0">{
                errorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("196"))
                b.WriteString(errorStyle.Render("Error: " + m.err.Error()))
                b.WriteString("\n\n")
        }</span>

        <span class="cov0" title="0">footerStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("241"))
        b.WriteString(footerStyle.Render("tab: next field  enter: create wallet  esc: back  q: quit"))

        return b.String()</span>
}

func (m Model) renderImportWallet() string <span class="cov0" title="0">{
        var b strings.Builder

        headerStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                MarginBottom(2)

        b.WriteString(headerStyle.Render(" Import Wallet"))
        b.WriteString("\n\n")

        b.WriteString("Fill in the details to import an existing wallet:\n\n")

        // Name input
        b.WriteString("Wallet Name:\n")
        b.WriteString(m.nameInput.View())
        b.WriteString("\n\n")

        // Password input
        b.WriteString("Password:\n")
        b.WriteString(m.passwordInput.View())
        b.WriteString("\n\n")

        // Mnemonic input
        b.WriteString("Mnemonic Phrase (12 words):\n")
        b.WriteString(m.mnemonicInput.View())
        b.WriteString("\n\n")

        if m.err != nil </span><span class="cov0" title="0">{
                errorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("196"))
                b.WriteString(errorStyle.Render("Error: " + m.err.Error()))
                b.WriteString("\n\n")
        }</span>

        <span class="cov0" title="0">footerStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("241"))
        b.WriteString(footerStyle.Render("tab: next field  enter: import wallet  esc: back  q: quit"))

        return b.String()</span>
}

func (m Model) renderImportPrivateKey() string <span class="cov0" title="0">{
        var b strings.Builder

        headerStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("86")).
                MarginBottom(2)

        b.WriteString(headerStyle.Render(" Import Wallet from Private Key"))
        b.WriteString("\n\n")

        b.WriteString("Fill in the details to import an existing wallet from a private key:\n\n")

        // Name input
        b.WriteString("Wallet Name:\n")
        b.WriteString(m.nameInput.View())
        b.WriteString("\n\n")

        // Password input
        b.WriteString("Password:\n")
        b.WriteString(m.passwordInput.View())
        b.WriteString("\n\n")

        // Private Key input
        b.WriteString("Private Key (without 0x prefix):\n")
        b.WriteString(m.privateKeyInput.View())
        b.WriteString("\n\n")

        if m.err != nil </span><span class="cov0" title="0">{
                errorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("196"))
                b.WriteString(errorStyle.Render("Error: " + m.err.Error()))
                b.WriteString("\n\n")
        }</span>

        <span class="cov0" title="0">footerStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("241"))
        b.WriteString(footerStyle.Render("tab: next field  enter: import wallet  esc: back  q: quit"))

        return b.String()</span>
}

// refreshNetworkItems updates the network items list
func (m *Model) refreshNetworkItems() <span class="cov0" title="0">{
        var networkItems []string
        networkKeys := m.config.GetAllNetworkKeys()
        for _, key := range networkKeys </span><span class="cov0" title="0">{
                if network, exists := m.config.GetNetworkByKey(key); exists </span><span class="cov0" title="0">{
                        status := ""
                        if network.IsActive </span><span class="cov0" title="0">{
                                status = " (Active)"
                        }</span>
                        <span class="cov0" title="0">customTag := ""
                        if network.IsCustom </span><span class="cov0" title="0">{
                                customTag = " [Custom]"
                        }</span>
                        <span class="cov0" title="0">networkItems = append(networkItems, fmt.Sprintf("%s%s%s", network.Name, status, customTag))</span>
                }
        }
        <span class="cov0" title="0">networkItems = append(networkItems, "Add Custom Network", "Back to Settings")
        m.networkItems = networkItems</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package ui

import (
        "context"
        "fmt"
        "strings"

        "blocowallet/internal/wallet"

        tea "github.com/charmbracelet/bubbletea"
)

// WalletOperations contm operaes especficas de wallet que podem ser reutilizadas
type WalletOperations struct {
        service *wallet.Service
}

// NewWalletOperations cria uma nova instncia de WalletOperations
func NewWalletOperations(service *wallet.Service) *WalletOperations <span class="cov0" title="0">{
        return &amp;WalletOperations{
                service: service,
        }
}</span>

// LoadWallets carrega todas as wallets
func (wo *WalletOperations) LoadWallets() ([]*wallet.Wallet, error) <span class="cov0" title="0">{
        return wo.service.List(context.Background())
}</span>

// CreateWallet cria uma nova wallet com mnemnico
func (wo *WalletOperations) CreateWallet(name, password string) (*wallet.WalletDetails, error) <span class="cov0" title="0">{
        return wo.service.CreateWalletWithMnemonic(context.Background(), name, password)
}</span>

// ImportWallet importa uma wallet usando mnemnico
func (wo *WalletOperations) ImportWallet(name, password, mnemonic string) (*wallet.WalletDetails, error) <span class="cov0" title="0">{
        return wo.service.ImportWalletFromMnemonic(context.Background(), name, mnemonic, password)
}</span>

// ImportWalletFromPrivateKey importa uma wallet usando chave privada
func (wo *WalletOperations) ImportWalletFromPrivateKey(name, password, privateKey string) (*wallet.WalletDetails, error) <span class="cov0" title="0">{
        return wo.service.ImportWalletFromPrivateKey(context.Background(), name, privateKey, password)
}</span>

// GetBalance obtm o saldo de uma wallet
func (wo *WalletOperations) GetBalance(address string) (*wallet.Balance, error) <span class="cov0" title="0">{
        return wo.service.GetBalance(context.Background(), address)
}</span>

// GetMultiNetworkBalance obtm o saldo em mltiplas redes
func (wo *WalletOperations) GetMultiNetworkBalance(address string) (*wallet.MultiNetworkBalance, error) <span class="cov0" title="0">{
        return wo.service.GetMultiNetworkBalance(context.Background(), address)
}</span>

// DeleteWallet exclui uma wallet pelo endereo
func (wo *WalletOperations) DeleteWallet(address string) error <span class="cov0" title="0">{
        return wo.service.DeleteWalletByAddress(context.Background(), address)
}</span>

// ValidateWalletInput valida os dados de entrada para criao de wallet
func ValidateWalletInput(name, password string) error <span class="cov8" title="1">{
        name = strings.TrimSpace(name)
        password = strings.TrimSpace(password)

        if name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("wallet name is required")
        }</span>
        <span class="cov8" title="1">if password == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("password is required")
        }</span>
        <span class="cov8" title="1">if len(password) &lt; 6 </span><span class="cov8" title="1">{
                return fmt.Errorf("password must be at least 6 characters long")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateImportInput valida os dados de entrada para importao de wallet
func ValidateImportInput(name, password, mnemonic string) error <span class="cov8" title="1">{
        if err := ValidateWalletInput(name, password); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">mnemonic = strings.TrimSpace(mnemonic)
        if mnemonic == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("mnemonic phrase is required")
        }</span>

        <span class="cov8" title="1">words := strings.Fields(mnemonic)
        if len(words) != 12 &amp;&amp; len(words) != 24 </span><span class="cov8" title="1">{
                return fmt.Errorf("mnemonic phrase must be 12 or 24 words")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidatePrivateKeyInput valida os dados de entrada para importao via chave privada
func ValidatePrivateKeyInput(name, password, privateKey string) error <span class="cov8" title="1">{
        if err := ValidateWalletInput(name, password); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">privateKey = strings.TrimSpace(privateKey)
        if privateKey == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("private key is required")
        }</span>

        // Remove 0x prefix if present
        <span class="cov8" title="1">if strings.HasPrefix(privateKey, "0x") </span><span class="cov0" title="0">{
                privateKey = privateKey[2:]
        }</span>

        <span class="cov8" title="1">if len(privateKey) != 64 </span><span class="cov8" title="1">{
                return fmt.Errorf("private key must be 64 hexadecimal characters")
        }</span>

        // Validate hex characters
        <span class="cov8" title="1">for _, c := range privateKey </span><span class="cov8" title="1">{
                if !((c &gt;= '0' &amp;&amp; c &lt;= '9') || (c &gt;= 'a' &amp;&amp; c &lt;= 'f') || (c &gt;= 'A' &amp;&amp; c &lt;= 'F')) </span><span class="cov0" title="0">{
                        return fmt.Errorf("private key must contain only hexadecimal characters")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// FormatWalletAddress formata um endereo de wallet para exibio
func FormatWalletAddress(address string) string <span class="cov0" title="0">{
        if len(address) &lt;= 13 </span><span class="cov0" title="0">{
                return address
        }</span>
        <span class="cov0" title="0">return address[:10] + "..."</span>
}

// WalletCommand types para comandos especficos de wallet
type WalletLoadedMsg []*wallet.Wallet
type WalletBalanceLoadedMsg *wallet.Balance
type WalletMultiBalanceLoadedMsg *wallet.MultiNetworkBalance
type WalletCreatedMsg struct{}
type WalletDeletedMsg struct{}
type WalletAuthenticatedMsg struct{}

// Wallet command creators
func CreateLoadWalletsCmd(wo *WalletOperations) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                wallets, err := wo.LoadWallets()
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg(err.Error())
                }</span>
                <span class="cov0" title="0">return WalletLoadedMsg(wallets)</span>
        })
}

func CreateGetBalanceCmd(wo *WalletOperations, address string) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                balance, err := wo.GetBalance(address)
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg(err.Error())
                }</span>
                <span class="cov0" title="0">return WalletBalanceLoadedMsg(balance)</span>
        })
}

func CreateGetMultiBalanceCmd(wo *WalletOperations, address string) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                multiBalance, err := wo.GetMultiNetworkBalance(address)
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg(err.Error())
                }</span>
                <span class="cov0" title="0">return WalletMultiBalanceLoadedMsg(multiBalance)</span>
        })
}

func CreateWalletCmd(wo *WalletOperations, name, password string) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                if err := ValidateWalletInput(name, password); err != nil </span><span class="cov0" title="0">{
                        return errorMsg(err.Error())
                }</span>

                <span class="cov0" title="0">_, err := wo.CreateWallet(name, password)
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg(err.Error())
                }</span>
                <span class="cov0" title="0">return WalletCreatedMsg{}</span>
        })
}

func ImportWalletCmd(wo *WalletOperations, name, password, mnemonic string) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                if err := ValidateImportInput(name, password, mnemonic); err != nil </span><span class="cov0" title="0">{
                        return errorMsg(err.Error())
                }</span>

                <span class="cov0" title="0">_, err := wo.ImportWallet(name, password, mnemonic)
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg(err.Error())
                }</span>
                <span class="cov0" title="0">return WalletCreatedMsg{}</span>
        })
}

func ImportPrivateKeyCmd(wo *WalletOperations, name, password, privateKey string) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                if err := ValidatePrivateKeyInput(name, password, privateKey); err != nil </span><span class="cov0" title="0">{
                        return errorMsg(err.Error())
                }</span>

                <span class="cov0" title="0">_, err := wo.ImportWalletFromPrivateKey(name, password, privateKey)
                if err != nil </span><span class="cov0" title="0">{
                        return errorMsg(err.Error())
                }</span>
                <span class="cov0" title="0">return WalletCreatedMsg{}</span>
        })
}

func DeleteWalletCmd(wo *WalletOperations, address string) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                if err := wo.DeleteWallet(address); err != nil </span><span class="cov0" title="0">{
                        return errorMsg(err.Error())
                }</span>
                <span class="cov0" title="0">return WalletDeletedMsg{}</span>
        })
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package wallet

import (
        "crypto/rand"
        "crypto/sha256"
        "crypto/subtle"
        "encoding/base64"
        "fmt"

        "golang.org/x/crypto/argon2"
)

// Argon2ID parameters for secure encryption
const (
        argon2IDTime    = 1         // Number of iterations
        argon2IDMemory  = 64 * 1024 // Memory usage in KB (64MB)
        argon2IDThreads = 4         // Number of threads
        argon2IDKeyLen  = 32        // Length of derived key
        saltLength      = 16        // Length of salt
        hashLength      = 32        // Length of verification hash (SHA256)
)

// EncryptMnemonic encrypts a mnemonic using Argon2ID
func EncryptMnemonic(mnemonic, password string) (string, error) <span class="cov8" title="1">{
        if password == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("password cannot be empty")
        }</span>

        // Generate random salt
        <span class="cov8" title="1">salt := make([]byte, saltLength)
        if _, err := rand.Read(salt); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate salt: %w", err)
        }</span>

        // Derive key using Argon2ID
        <span class="cov8" title="1">key := argon2.IDKey([]byte(password), salt, argon2IDTime, argon2IDMemory, argon2IDThreads, argon2IDKeyLen)

        // Create verification hash of original mnemonic + password
        // This ensures that even empty mnemonics have unique hashes per password
        mnemonicBytes := []byte(mnemonic)
        hashInput := append(mnemonicBytes, []byte(password)...)
        hash := sha256.Sum256(hashInput)

        // XOR encrypt the mnemonic
        encrypted := make([]byte, len(mnemonicBytes))

        // Repeat key if mnemonic is longer than key
        for i := 0; i &lt; len(mnemonicBytes); i++ </span><span class="cov8" title="1">{
                encrypted[i] = mnemonicBytes[i] ^ key[i%len(key)]
        }</span>

        // Combine salt + hash + encrypted data and encode to base64
        <span class="cov8" title="1">combined := append(salt, hash[:]...)
        combined = append(combined, encrypted...)
        return base64.StdEncoding.EncodeToString(combined), nil</span>
}

// DecryptMnemonic decrypts a mnemonic using Argon2ID
func DecryptMnemonic(encryptedMnemonic, password string) (string, error) <span class="cov8" title="1">{
        if encryptedMnemonic == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("encrypted mnemonic cannot be empty")
        }</span>
        <span class="cov8" title="1">if password == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("password cannot be empty")
        }</span>

        // Decode from base64
        <span class="cov8" title="1">combined, err := base64.StdEncoding.DecodeString(encryptedMnemonic)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to decode encrypted mnemonic: %w", err)
        }</span>

        <span class="cov8" title="1">if len(combined) &lt; saltLength+hashLength </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid encrypted mnemonic: too short")
        }</span>

        // Extract salt, hash, and encrypted data
        <span class="cov8" title="1">salt := combined[:saltLength]
        expectedHash := combined[saltLength : saltLength+hashLength]
        encrypted := combined[saltLength+hashLength:]

        // Derive key using Argon2ID with the same parameters
        key := argon2.IDKey([]byte(password), salt, argon2IDTime, argon2IDMemory, argon2IDThreads, argon2IDKeyLen)

        // XOR decrypt the mnemonic
        decrypted := make([]byte, len(encrypted))
        for i := 0; i &lt; len(encrypted); i++ </span><span class="cov8" title="1">{
                decrypted[i] = encrypted[i] ^ key[i%len(key)]
        }</span>

        // Verify the hash to ensure the password is correct
        // Use the same scheme: hash(mnemonic + password)
        <span class="cov8" title="1">hashInput := append(decrypted, []byte(password)...)
        actualHash := sha256.Sum256(hashInput)
        if subtle.ConstantTimeCompare(expectedHash, actualHash[:]) != 1 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid password: hash verification failed")
        }</span>

        <span class="cov8" title="1">mnemonic := string(decrypted)

        // Return the decrypted mnemonic without strict word validation
        // This allows for edge cases and test scenarios
        return mnemonic, nil</span>
}

// VerifyMnemonicPassword verifies if the password can decrypt the mnemonic
func VerifyMnemonicPassword(encryptedMnemonic, password string) bool <span class="cov8" title="1">{
        _, err := DecryptMnemonic(encryptedMnemonic, password)
        return err == nil
}</span>

// SecureCompare performs constant-time comparison of two strings
func SecureCompare(a, b string) bool <span class="cov8" title="1">{
        return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package wallet

import (
        "context"
        "crypto/ecdsa"
        "encoding/hex"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"

        "blocowallet/internal/blockchain"
        "blocowallet/pkg/config"

        "github.com/ethereum/go-ethereum/accounts/keystore"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/google/uuid"
)

// KeystoreFile represents the structure of a keystore JSON file
type KeystoreFile struct {
        Address string `json:"address"`
        Crypto  struct {
                Cipher       string `json:"cipher"`
                CipherText   string `json:"ciphertext"`
                CipherParams struct {
                        IV string `json:"iv"`
                } `json:"cipherparams"`
                KDF       string `json:"kdf"`
                KDFParams struct {
                        DKLen int    `json:"dklen"`
                        Salt  string `json:"salt"`
                        N     int    `json:"n"`
                        R     int    `json:"r"`
                        P     int    `json:"p"`
                } `json:"kdfparams"`
                MAC string `json:"mac"`
        } `json:"crypto"`
        ID      string `json:"id"`
        Version int    `json:"version"`
}

// KeyStore V3 constants
const (
        KeyStoreV3Dir   = ".blocowallet/keystore"
        KeyStoreVersion = 3
)

// Service provides wallet business logic
type Service struct {
        repo            Repository
        balanceProvider BalanceProvider
        multiProvider   *blockchain.MultiProvider
        keystore        *keystore.KeyStore
        passwordCache   map[string]string // Cache for wallet passwords
        passwordMutex   sync.RWMutex      // Mutex for thread-safe password cache access
}

// NewService creates a new wallet service
func NewService(repo Repository, balanceProvider BalanceProvider) *Service <span class="cov8" title="1">{
        return &amp;Service{
                repo:            repo,
                balanceProvider: balanceProvider,
                passwordCache:   make(map[string]string),
        }
}</span>

// NewServiceWithMultiProvider creates a new wallet service with multi-provider support
func NewServiceWithMultiProvider(repo Repository, multiProvider *blockchain.MultiProvider) *Service <span class="cov0" title="0">{
        return &amp;Service{
                repo:          repo,
                multiProvider: multiProvider,
                passwordCache: make(map[string]string),
        }
}</span>

// NewServiceWithKeystore creates a new wallet service with keystore support
func NewServiceWithKeystore(repo Repository, balanceProvider BalanceProvider, ks *keystore.KeyStore) *Service <span class="cov0" title="0">{
        return &amp;Service{
                repo:            repo,
                balanceProvider: balanceProvider,
                keystore:        ks,
                passwordCache:   make(map[string]string),
        }
}</span>

// NewServiceWithMultiProviderAndKeystore creates a new wallet service with multi-provider and keystore support
func NewServiceWithMultiProviderAndKeystore(repo Repository, multiProvider *blockchain.MultiProvider, ks *keystore.KeyStore) *Service <span class="cov0" title="0">{
        return &amp;Service{
                repo:          repo,
                multiProvider: multiProvider,
                keystore:      ks,
                passwordCache: make(map[string]string),
        }
}</span>

// Create creates a new wallet
func (s *Service) Create(ctx context.Context, name, address, keystorePath string) (*Wallet, error) <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("wallet name cannot be empty")
        }</span>

        <span class="cov8" title="1">if address == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet address cannot be empty")
        }</span>

        // Check if wallet with this address already exists
        <span class="cov8" title="1">existing, err := s.repo.GetByAddress(ctx, address)
        if err == nil &amp;&amp; existing != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet with address %s already exists", address)
        }</span>

        <span class="cov8" title="1">wallet := &amp;Wallet{
                ID:           uuid.New().String(),
                Name:         name,
                Address:      address,
                KeyStorePath: keystorePath,
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }

        if err := s.repo.Create(ctx, wallet); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create wallet: %w", err)
        }</span>

        <span class="cov8" title="1">return wallet, nil</span>
}

// GetByID retrieves a wallet by ID
func (s *Service) GetByID(ctx context.Context, id string) (*Wallet, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet ID cannot be empty")
        }</span>

        <span class="cov8" title="1">wallet, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get wallet: %w", err)
        }</span>

        <span class="cov8" title="1">return wallet, nil</span>
}

// GetByAddress retrieves a wallet by address
func (s *Service) GetByAddress(ctx context.Context, address string) (*Wallet, error) <span class="cov8" title="1">{
        if address == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet address cannot be empty")
        }</span>

        <span class="cov8" title="1">wallet, err := s.repo.GetByAddress(ctx, address)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get wallet: %w", err)
        }</span>

        <span class="cov8" title="1">return wallet, nil</span>
}

// List retrieves all wallets
func (s *Service) List(ctx context.Context) ([]*Wallet, error) <span class="cov8" title="1">{
        wallets, err := s.repo.List(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list wallets: %w", err)
        }</span>

        <span class="cov8" title="1">return wallets, nil</span>
}

// Update updates a wallet
func (s *Service) Update(ctx context.Context, wallet *Wallet) error <span class="cov8" title="1">{
        if wallet == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("wallet cannot be nil")
        }</span>

        <span class="cov8" title="1">if wallet.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("wallet ID cannot be empty")
        }</span>

        <span class="cov8" title="1">wallet.UpdatedAt = time.Now()

        if err := s.repo.Update(ctx, wallet); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to update wallet: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Delete deletes a wallet
func (s *Service) Delete(ctx context.Context, id string) error <span class="cov8" title="1">{
        if id == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("wallet ID cannot be empty")
        }</span>

        <span class="cov8" title="1">if err := s.repo.Delete(ctx, id); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete wallet: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetBalance gets the balance for a wallet
func (s *Service) GetBalance(ctx context.Context, address string) (*Balance, error) <span class="cov0" title="0">{
        if address == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet address cannot be empty")
        }</span>

        <span class="cov0" title="0">amount, err := s.balanceProvider.GetBalance(ctx, address)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get balance: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Balance{
                Address:   address,
                Amount:    amount,
                Symbol:    "ETH",
                Decimals:  18,
                UpdatedAt: time.Now(),
        }, nil</span>
}

// CreateWalletWithMnemonic creates a new wallet with mnemonic and keystore
func (s *Service) CreateWalletWithMnemonic(ctx context.Context, name, password string) (*WalletDetails, error) <span class="cov8" title="1">{
        if name == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet name cannot be empty")
        }</span>

        <span class="cov8" title="1">if password == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("password cannot be empty")
        }</span>

        // Generate mnemonic
        <span class="cov8" title="1">mnemonic, err := GenerateMnemonic()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate mnemonic: %w", err)
        }</span>

        // Derive private key
        <span class="cov8" title="1">privateKeyHex, err := DerivePrivateKey(mnemonic)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to derive private key: %w", err)
        }</span>

        <span class="cov8" title="1">privKey, err := HexToECDSA(privateKeyHex)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert private key: %w", err)
        }</span>

        // Get address
        <span class="cov8" title="1">address := GetAddressFromPrivateKey(privKey)

        // Create KeyStore V3 file in proper directory structure
        keystorePath, err := s.CreateKeyStoreV3File(privKey, password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create keystore file: %w", err)
        }</span>

        // Encrypt mnemonic for secure storage in database
        <span class="cov8" title="1">encryptedMnemonic, err := EncryptMnemonic(mnemonic, password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encrypt mnemonic: %w", err)
        }</span>

        // Create wallet entity - store encrypted mnemonic
        <span class="cov8" title="1">wallet := &amp;Wallet{
                ID:                uuid.New().String(),
                Name:              name,
                Address:           address,
                KeyStorePath:      keystorePath,
                EncryptedMnemonic: encryptedMnemonic,
                CreatedAt:         time.Now(),
                UpdatedAt:         time.Now(),
        }

        // Save to repository
        if err := s.repo.Create(ctx, wallet); err != nil </span><span class="cov0" title="0">{
                // If database save fails and keystore was created, try to clean up
                if s.keystore != nil &amp;&amp; keystorePath != "" </span><span class="cov0" title="0">{
                        os.Remove(keystorePath)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to save wallet: %w", err)</span>
        }

        // Get public key
        <span class="cov8" title="1">publicKey := privKey.Public()
        publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get public key")
        }</span>

        <span class="cov8" title="1">return &amp;WalletDetails{
                Wallet:     wallet,
                Mnemonic:   mnemonic,
                PrivateKey: privKey,
                PublicKey:  publicKeyECDSA,
        }, nil</span>
}

// ImportWalletFromMnemonic imports a wallet from an existing mnemonic
func (s *Service) ImportWalletFromMnemonic(ctx context.Context, name, mnemonic, password string) (*WalletDetails, error) <span class="cov8" title="1">{
        if name == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet name cannot be empty")
        }</span>

        <span class="cov8" title="1">if mnemonic == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("mnemonic cannot be empty")
        }</span>

        <span class="cov8" title="1">if password == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("password cannot be empty")
        }</span>

        // Validate mnemonic
        <span class="cov8" title="1">if !IsValidMnemonic(mnemonic) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid mnemonic phrase")
        }</span>

        // Derive private key
        <span class="cov8" title="1">privateKeyHex, err := DerivePrivateKey(mnemonic)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to derive private key: %w", err)
        }</span>

        <span class="cov8" title="1">privKey, err := HexToECDSA(privateKeyHex)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert private key: %w", err)
        }</span>

        // Get address
        <span class="cov8" title="1">address := GetAddressFromPrivateKey(privKey)

        // Check if wallet already exists
        existing, err := s.repo.GetByAddress(ctx, address)
        if err == nil &amp;&amp; existing != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet with address %s already exists", address)
        }</span>

        // Create KeyStore V3 file in proper directory structure
        <span class="cov8" title="1">keystorePath, err := s.CreateKeyStoreV3File(privKey, password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create keystore file: %w", err)
        }</span>

        // Encrypt mnemonic for secure storage in database
        <span class="cov8" title="1">encryptedMnemonic, err := EncryptMnemonic(mnemonic, password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encrypt mnemonic: %w", err)
        }</span>

        // Create wallet entity - store encrypted mnemonic
        <span class="cov8" title="1">wallet := &amp;Wallet{
                ID:                uuid.New().String(),
                Name:              name,
                Address:           address,
                KeyStorePath:      keystorePath,
                EncryptedMnemonic: encryptedMnemonic,
                CreatedAt:         time.Now(),
                UpdatedAt:         time.Now(),
        }

        // Save to repository
        if err := s.repo.Create(ctx, wallet); err != nil </span><span class="cov0" title="0">{
                // If database save fails and keystore was created, try to clean up
                if s.keystore != nil &amp;&amp; keystorePath != "" </span><span class="cov0" title="0">{
                        os.Remove(keystorePath)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to save wallet: %w", err)</span>
        }

        // Get public key
        <span class="cov8" title="1">publicKey := privKey.Public()
        publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get public key")
        }</span>

        <span class="cov8" title="1">return &amp;WalletDetails{
                Wallet:     wallet,
                Mnemonic:   mnemonic,
                PrivateKey: privKey,
                PublicKey:  publicKeyECDSA,
        }, nil</span>
}

// ImportWalletFromPrivateKey imports a wallet from a private key
func (s *Service) ImportWalletFromPrivateKey(ctx context.Context, name, privateKeyHex, password string) (*WalletDetails, error) <span class="cov8" title="1">{
        if name == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet name cannot be empty")
        }</span>

        <span class="cov8" title="1">if privateKeyHex == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("private key cannot be empty")
        }</span>

        <span class="cov8" title="1">if password == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("password cannot be empty")
        }</span>

        // Remove 0x prefix if present
        <span class="cov8" title="1">if len(privateKeyHex) &gt; 2 &amp;&amp; privateKeyHex[:2] == "0x" </span><span class="cov0" title="0">{
                privateKeyHex = privateKeyHex[2:]
        }</span>

        // Convert hex string to ECDSA private key
        <span class="cov8" title="1">privKey, err := HexToECDSA(privateKeyHex)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid private key: %w", err)
        }</span>

        // Derive address from private key
        <span class="cov8" title="1">address := GetAddressFromPrivateKey(privKey)

        // Check if wallet already exists
        existingWallets, err := s.repo.List(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing wallets: %w", err)
        }</span>

        <span class="cov8" title="1">for _, existingWallet := range existingWallets </span><span class="cov0" title="0">{
                if existingWallet.Address == address </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("wallet with address %s already exists", address)
                }</span>
                <span class="cov0" title="0">if existingWallet.Name == name </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("wallet with name %s already exists", name)
                }</span>
        }

        // Create KeyStore V3 file to store the private key securely
        <span class="cov8" title="1">keystorePath, err := s.CreateKeyStoreV3File(privKey, password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create keystore file: %w", err)
        }</span>

        // Create wallet object - NO private key stored in database, only keystore path
        // Private key imports don't have mnemonic, so EncryptedMnemonic is empty
        <span class="cov8" title="1">wallet := &amp;Wallet{
                ID:                uuid.New().String(),
                Name:              name,
                Address:           address,
                KeyStorePath:      keystorePath,
                EncryptedMnemonic: "", // Private key imports don't have mnemonic
                CreatedAt:         time.Now(),
                UpdatedAt:         time.Now(),
        }

        // Save to repository
        err = s.repo.Create(ctx, wallet)
        if err != nil </span><span class="cov0" title="0">{
                // If database save fails and keystore was created, try to clean up
                if s.keystore != nil &amp;&amp; keystorePath != "" </span><span class="cov0" title="0">{
                        os.Remove(keystorePath)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to save wallet: %w", err)</span>
        }

        // Get public key
        <span class="cov8" title="1">publicKey := privKey.Public()
        publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get public key")
        }</span>

        <span class="cov8" title="1">return &amp;WalletDetails{
                Wallet:     wallet,
                PrivateKey: privKey,
                PublicKey:  publicKeyECDSA,
        }, nil</span>
}

// ExtractPrivateKeyFromKeystore extracts the private key from a keystore file
func (s *Service) ExtractPrivateKeyFromKeystore(keystorePath, password string) (string, error) <span class="cov0" title="0">{
        if keystorePath == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("keystore path is empty")
        }</span>

        <span class="cov0" title="0">if password == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("password is required to decrypt keystore")
        }</span>

        // Use the new LoadPrivateKeyFromKeyStoreV3 method
        <span class="cov0" title="0">privateKey, err := s.LoadPrivateKeyFromKeyStoreV3(keystorePath, password)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to load private key from keystore: %w", err)
        }</span>

        // Convert private key to hex string
        <span class="cov0" title="0">privateKeyBytes := crypto.FromECDSA(privateKey)
        return hex.EncodeToString(privateKeyBytes), nil</span>
}

// CreateKeyStoreV3File creates a KeyStore V3 file in the proper directory structure
func (s *Service) CreateKeyStoreV3File(privateKey *ecdsa.PrivateKey, password string) (string, error) <span class="cov8" title="1">{
        if password == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("password cannot be empty")
        }</span>

        <span class="cov8" title="1">address := GetAddressFromPrivateKey(privateKey)

        // Get home directory
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        // Create keystore directory if it doesn't exist
        <span class="cov8" title="1">keystoreDir := filepath.Join(homeDir, KeyStoreV3Dir)
        if err := os.MkdirAll(keystoreDir, 0700); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create keystore directory: %w", err)
        }</span>

        // Create temporary keystore to generate the encrypted key
        <span class="cov8" title="1">tempDir, err := os.MkdirTemp("", "blocowallet_temp")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create temp directory: %w", err)
        }</span>
        <span class="cov8" title="1">defer os.RemoveAll(tempDir)

        // Create temporary keystore
        tempKeystore := keystore.NewKeyStore(tempDir, keystore.StandardScryptN, keystore.StandardScryptP)

        // Import the key to generate encrypted keystore file
        account, err := tempKeystore.ImportECDSA(privateKey, password)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to encrypt private key: %w", err)
        }</span>

        // Read the generated keystore file
        <span class="cov8" title="1">keystoreData, err := os.ReadFile(account.URL.Path)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read keystore file: %w", err)
        }</span>

        // Define the final keystore file path
        <span class="cov8" title="1">fileName := fmt.Sprintf("%s.json", address)
        finalPath := filepath.Join(keystoreDir, fileName)

        // Write to final location
        if err := os.WriteFile(finalPath, keystoreData, 0600); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to write keystore file: %w", err)
        }</span>

        <span class="cov8" title="1">return finalPath, nil</span>
}

// LoadPrivateKeyFromKeyStoreV3 loads a private key from a KeyStore V3 file
func (s *Service) LoadPrivateKeyFromKeyStoreV3(keystorePath, password string) (*ecdsa.PrivateKey, error) <span class="cov8" title="1">{
        // Read keystore file
        keystoreData, err := os.ReadFile(keystorePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read keystore file: %w", err)
        }</span>

        // Use keystore.DecryptKey directly to decrypt the JSON keystore
        <span class="cov8" title="1">key, err := keystore.DecryptKey(keystoreData, password)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to decrypt keystore with password: %w", err)
        }</span>

        <span class="cov8" title="1">return key.PrivateKey, nil</span>
}

// GetMnemonicFromWallet retrieves and decrypts the mnemonic for a wallet
func (s *Service) GetMnemonicFromWallet(wallet *Wallet, password string) (string, error) <span class="cov8" title="1">{
        if wallet.EncryptedMnemonic == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("wallet has no mnemonic (imported from private key)")
        }</span>

        // Decrypt the mnemonic
        <span class="cov8" title="1">mnemonic, err := DecryptMnemonic(wallet.EncryptedMnemonic, password)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to decrypt mnemonic: %w", err)
        }</span>

        <span class="cov8" title="1">return mnemonic, nil</span>
}

// GetAllWallets retrieves all wallets (alias for List for backward compatibility)
func (s *Service) GetAllWallets(ctx context.Context) ([]*Wallet, error) <span class="cov0" title="0">{
        return s.List(ctx)
}</span>

// DeleteWalletByAddress deletes a wallet by address and cleans up keystore
func (s *Service) DeleteWalletByAddress(ctx context.Context, address string) error <span class="cov0" title="0">{
        if address == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("address cannot be empty")
        }</span>

        // Get wallet first to get keystore path
        <span class="cov0" title="0">wallet, err := s.repo.GetByAddress(ctx, address)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get wallet: %w", err)
        }</span>

        // Delete from database
        <span class="cov0" title="0">if err := s.repo.Delete(ctx, wallet.ID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete wallet from database: %w", err)
        }</span>

        // Clean up keystore file if it exists
        <span class="cov0" title="0">if wallet.KeyStorePath != "" </span><span class="cov0" title="0">{
                if err := os.Remove(wallet.KeyStorePath); err != nil </span><span class="cov0" title="0">{
                        // Log the error but don't fail the operation
                        // The wallet is already deleted from the database
                        fmt.Printf("Warning: failed to delete keystore file %s: %v\n", wallet.KeyStorePath, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// RefreshMultiProvider updates the multi-provider with current network configuration
func (s *Service) RefreshMultiProvider(cfg *config.Config) <span class="cov0" title="0">{
        if s.multiProvider != nil </span><span class="cov0" title="0">{
                s.multiProvider.RefreshProviders(cfg)
        }</span>
}

// GetMultiNetworkBalance gets the balance for a wallet across all active networks
func (s *Service) GetMultiNetworkBalance(ctx context.Context, address string) (*MultiNetworkBalance, error) <span class="cov0" title="0">{
        if address == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet address cannot be empty")
        }</span>

        <span class="cov0" title="0">if s.multiProvider == nil </span><span class="cov0" title="0">{
                // Fallback to single provider if multiProvider is not available
                if s.balanceProvider != nil </span><span class="cov0" title="0">{
                        amount, err := s.balanceProvider.GetBalance(ctx, address)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to get balance: %w", err)
                        }</span>

                        <span class="cov0" title="0">return &amp;MultiNetworkBalance{
                                Address: address,
                                NetworkBalances: []*NetworkBalance{
                                        {
                                                NetworkKey:  "ethereum",
                                                NetworkName: "Ethereum",
                                                Amount:      amount,
                                                Symbol:      s.balanceProvider.GetNetworkSymbol(),
                                                Decimals:    s.balanceProvider.GetNetworkDecimals(),
                                        },
                                },
                                UpdatedAt: time.Now(),
                        }, nil</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("no balance provider available")</span>
        }

        // Use multi-provider to get balances from all active networks
        <span class="cov0" title="0">networkBalances := s.multiProvider.GetAllBalances(ctx, address)

        result := &amp;MultiNetworkBalance{
                Address:         address,
                NetworkBalances: make([]*NetworkBalance, 0, len(networkBalances)),
                UpdatedAt:       time.Now(),
        }

        // Convert blockchain.NetworkBalance to wallet.NetworkBalance
        for _, nb := range networkBalances </span><span class="cov0" title="0">{
                balance := &amp;NetworkBalance{
                        NetworkKey:  nb.NetworkKey,
                        NetworkName: nb.NetworkName,
                        Amount:      nb.Amount,
                        Symbol:      nb.Symbol,
                        Decimals:    nb.Decimals,
                }

                if nb.Error != nil </span><span class="cov0" title="0">{
                        balance.Error = nb.Error
                }</span>

                <span class="cov0" title="0">result.NetworkBalances = append(result.NetworkBalances, balance)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// SetWalletPassword stores the password for a wallet address in memory
func (s *Service) SetWalletPassword(address, password string) <span class="cov8" title="1">{
        s.passwordMutex.Lock()
        defer s.passwordMutex.Unlock()
        s.passwordCache[address] = password
}</span>

// GetWalletPassword retrieves the cached password for a wallet address
func (s *Service) GetWalletPassword(address string) (string, bool) <span class="cov8" title="1">{
        s.passwordMutex.RLock()
        defer s.passwordMutex.RUnlock()
        password, exists := s.passwordCache[address]
        return password, exists
}</span>

// ClearWalletPassword removes the cached password for a wallet address
func (s *Service) ClearWalletPassword(address string) <span class="cov8" title="1">{
        s.passwordMutex.Lock()
        defer s.passwordMutex.Unlock()
        delete(s.passwordCache, address)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package wallet

import (
        "context"
        "crypto/ecdsa"
        "encoding/hex"
        "fmt"
        "math/big"
        "time"

        "github.com/ethereum/go-ethereum/crypto"
        "github.com/tyler-smith/go-bip32"
        "github.com/tyler-smith/go-bip39"
)

// Wallet represents a blockchain wallet
type Wallet struct {
        ID                string    `json:"id" db:"id"`
        Name              string    `json:"name" db:"name"`
        Address           string    `json:"address" db:"address"`
        KeyStorePath      string    `json:"keystore_path" db:"keystore_path"`
        EncryptedMnemonic string    `json:"encrypted_mnemonic,omitempty" db:"encrypted_mnemonic"`
        CreatedAt         time.Time `json:"created_at" db:"created_at"`
        UpdatedAt         time.Time `json:"updated_at" db:"updated_at"`
}

// Repository defines wallet storage operations
type Repository interface {
        Create(ctx context.Context, wallet *Wallet) error
        GetByID(ctx context.Context, id string) (*Wallet, error)
        GetByAddress(ctx context.Context, address string) (*Wallet, error)
        List(ctx context.Context) ([]*Wallet, error)
        Update(ctx context.Context, wallet *Wallet) error
        Delete(ctx context.Context, id string) error
        Close() error
}

// Balance represents wallet balance information
type Balance struct {
        Address   string    `json:"address"`
        Amount    *big.Int  `json:"amount"`
        Symbol    string    `json:"symbol"`
        Decimals  int       `json:"decimals"`
        UpdatedAt time.Time `json:"updated_at"`
}

// MultiNetworkBalance represents a wallet balance across multiple networks
type MultiNetworkBalance struct {
        Address         string            `json:"address"`
        NetworkBalances []*NetworkBalance `json:"network_balances"`
        UpdatedAt       time.Time         `json:"updated_at"`
}

// NetworkBalance represents a balance on a specific network
type NetworkBalance struct {
        NetworkKey  string   `json:"network_key"`
        NetworkName string   `json:"network_name"`
        Amount      *big.Int `json:"amount"`
        Symbol      string   `json:"symbol"`
        Decimals    int      `json:"decimals"`
        Error       error    `json:"error,omitempty"`
}

// BalanceProvider defines operations for getting balance from blockchain
type BalanceProvider interface {
        GetBalance(ctx context.Context, address string) (*big.Int, error)
        GetNetworkSymbol() string
        GetNetworkDecimals() int
}

// Cryptographic helper functions for wallet creation

// GenerateMnemonic creates a new BIP39 mnemonic phrase
func GenerateMnemonic() (string, error) <span class="cov8" title="1">{
        entropy, err := bip39.NewEntropy(128)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate entropy: %w", err)
        }</span>

        <span class="cov8" title="1">mnemonic, err := bip39.NewMnemonic(entropy)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate mnemonic: %w", err)
        }</span>

        <span class="cov8" title="1">return mnemonic, nil</span>
}

// DerivePrivateKey derives a private key from a mnemonic phrase using BIP44 derivation path
func DerivePrivateKey(mnemonic string) (string, error) <span class="cov8" title="1">{
        if !bip39.IsMnemonicValid(mnemonic) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid mnemonic phrase")
        }</span>

        <span class="cov8" title="1">seed := bip39.NewSeed(mnemonic, "")

        // BIP44 derivation path for Ethereum: m/44'/60'/0'/0/0
        masterKey, err := bip32.NewMasterKey(seed)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create master key: %w", err)
        }</span>

        // Purpose (44')
        <span class="cov8" title="1">purposeKey, err := masterKey.NewChildKey(bip32.FirstHardenedChild + 44)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to derive purpose key: %w", err)
        }</span>

        // Coin type (60' for Ethereum)
        <span class="cov8" title="1">coinTypeKey, err := purposeKey.NewChildKey(bip32.FirstHardenedChild + 60)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to derive coin type key: %w", err)
        }</span>

        // Account (0')
        <span class="cov8" title="1">accountKey, err := coinTypeKey.NewChildKey(bip32.FirstHardenedChild + 0)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to derive account key: %w", err)
        }</span>

        // Change (0)
        <span class="cov8" title="1">changeKey, err := accountKey.NewChildKey(0)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to derive change key: %w", err)
        }</span>

        // Address index (0)
        <span class="cov8" title="1">addressKey, err := changeKey.NewChildKey(0)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to derive address key: %w", err)
        }</span>

        <span class="cov8" title="1">privateKeyBytes := addressKey.Key
        return hex.EncodeToString(privateKeyBytes), nil</span>
}

// HexToECDSA converts a hex string to an ECDSA private key
func HexToECDSA(hexkey string) (*ecdsa.PrivateKey, error) <span class="cov8" title="1">{
        privateKeyBytes, err := hex.DecodeString(hexkey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode hex string: %w", err)
        }</span>

        <span class="cov8" title="1">privateKey, err := crypto.ToECDSA(privateKeyBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert to ECDSA: %w", err)
        }</span>

        <span class="cov8" title="1">return privateKey, nil</span>
}

// GetAddressFromPrivateKey derives an Ethereum address from a private key
func GetAddressFromPrivateKey(privateKey *ecdsa.PrivateKey) string <span class="cov8" title="1">{
        publicKey := privateKey.Public()
        publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">address := crypto.PubkeyToAddress(*publicKeyECDSA)
        return address.Hex()</span>
}

// WalletDetails contains full wallet information including cryptographic details
type WalletDetails struct {
        Wallet     *Wallet
        Mnemonic   string
        PrivateKey *ecdsa.PrivateKey
        PublicKey  *ecdsa.PublicKey
}

// IsValidMnemonic validates a BIP39 mnemonic phrase
func IsValidMnemonic(mnemonic string) bool <span class="cov8" title="1">{
        return bip39.IsMnemonicValid(mnemonic)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "sort"
)

type Config struct {
        Language       string             `json:"language"`
        Networks       map[string]Network `json:"networks"`
        CustomNetworks map[string]Network `json:"custom_networks"`
        Database       DatabaseConfig     `json:"database"`
        UIConfig       UIConfig           `json:"ui"`
}

type Network struct {
        Name        string `json:"name"`
        RPCEndpoint string `json:"rpc_endpoint"`
        ChainID     int64  `json:"chain_id"`
        Symbol      string `json:"symbol"`
        Explorer    string `json:"explorer"`
        IsActive    bool   `json:"is_active"`
        IsCustom    bool   `json:"is_custom"`
}

type DatabaseConfig struct {
        Type string `json:"type"` // sqlite, postgres
        Path string `json:"path"` // for sqlite
        URL  string `json:"url"`  // for postgres
}

type UIConfig struct {
        Theme      string `json:"theme"`
        ShowSplash bool   `json:"show_splash"`
}

var DefaultNetworks = map[string]Network{
        "ethereum": {
                Name:        "Ethereum Mainnet",
                RPCEndpoint: "https://eth.drpc.org",
                ChainID:     1,
                Symbol:      "ETH",
                Explorer:    "https://etherscan.io",
                IsActive:    true,
                IsCustom:    false,
        },
        "polygon": {
                Name:        "Polygon",
                RPCEndpoint: "https://polygon-rpc.com",
                ChainID:     137,
                Symbol:      "POL",
                Explorer:    "https://polygonscan.com",
                IsActive:    false,
                IsCustom:    false,
        },
        "bsc": {
                Name:        "Binance Smart Chain",
                RPCEndpoint: "https://bsc-dataseed.binance.org",
                ChainID:     56,
                Symbol:      "BNB",
                Explorer:    "https://bscscan.com",
                IsActive:    false,
                IsCustom:    false,
        },
        "base": {
                Name:        "Base",
                RPCEndpoint: "https://mainnet.base.org",
                ChainID:     8453,
                Symbol:      "ETH",
                Explorer:    "https://basescan.org",
                IsActive:    false,
                IsCustom:    false,
        },
}

var SupportedLanguages = map[string]string{
        "en": "English",
        "pt": "Portugus",
        "es": "Espaol",
        "fr": "Franais",
}

func DefaultConfig() *Config <span class="cov8" title="1">{
        homeDir, _ := os.UserHomeDir()
        return &amp;Config{
                Language:       "en",
                Networks:       DefaultNetworks,
                CustomNetworks: make(map[string]Network),
                Database: DatabaseConfig{
                        Type: "sqlite",
                        Path: filepath.Join(homeDir, ".blocowallet", "wallets.db"),
                },
                UIConfig: UIConfig{
                        Theme:      "default",
                        ShowSplash: true,
                },
        }
}</span>

func LoadConfig() (*Config, error) <span class="cov8" title="1">{
        configPath := getConfigPath()

        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                cfg := DefaultConfig()
                if err := cfg.Save(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create default config: %w", err)
                }</span>
                <span class="cov0" title="0">return cfg, nil</span>
        }

        <span class="cov8" title="1">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov8" title="1">var cfg Config
        if err := json.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        // Merge with default networks if missing
        <span class="cov8" title="1">if cfg.Networks == nil </span><span class="cov0" title="0">{
                cfg.Networks = DefaultNetworks
        }</span>

        // Initialize custom networks if missing
        <span class="cov8" title="1">if cfg.CustomNetworks == nil </span><span class="cov0" title="0">{
                cfg.CustomNetworks = make(map[string]Network)
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

func (c *Config) Save() error <span class="cov8" title="1">{
        configPath := getConfigPath()

        // Criar diretrio se no existir
        if err := os.MkdirAll(filepath.Dir(configPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        <span class="cov8" title="1">data, err := json.MarshalIndent(c, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(configPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func getConfigPath() string <span class="cov8" title="1">{
        homeDir, _ := os.UserHomeDir()
        return filepath.Join(homeDir, ".blocowallet", "config.json")
}</span>

func (c *Config) GetActiveNetwork() *Network <span class="cov0" title="0">{
        for _, network := range c.Networks </span><span class="cov0" title="0">{
                if network.IsActive </span><span class="cov0" title="0">{
                        return &amp;network
                }</span>
        }
        // Retorna Ethereum como padro se nenhuma estiver ativa
        <span class="cov0" title="0">if eth, exists := c.Networks["ethereum"]; exists </span><span class="cov0" title="0">{
                return &amp;eth
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *Config) SetActiveNetwork(networkKey string) error <span class="cov0" title="0">{
        // Deactivate all networks first
        for k, v := range c.Networks </span><span class="cov0" title="0">{
                v.IsActive = false
                c.Networks[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range c.CustomNetworks </span><span class="cov0" title="0">{
                v.IsActive = false
                c.CustomNetworks[k] = v
        }</span>

        // Activate the selected network
        <span class="cov0" title="0">if network, exists := c.Networks[networkKey]; exists </span><span class="cov0" title="0">{
                network.IsActive = true
                c.Networks[networkKey] = network
                return nil
        }</span>

        <span class="cov0" title="0">if network, exists := c.CustomNetworks[networkKey]; exists </span><span class="cov0" title="0">{
                network.IsActive = true
                c.CustomNetworks[networkKey] = network
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("network %s not found", networkKey)</span>
}

func (c *Config) UpdateNetworkRPC(networkKey, rpcEndpoint string) error <span class="cov0" title="0">{
        if network, exists := c.Networks[networkKey]; exists </span><span class="cov0" title="0">{
                network.RPCEndpoint = rpcEndpoint
                c.Networks[networkKey] = network
                return nil
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("network %s not found", networkKey)</span>
}

func (c *Config) GetNetworkKeys() []string <span class="cov0" title="0">{
        var keys []string
        for key := range c.Networks </span><span class="cov0" title="0">{
                keys = append(keys, key)
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)
        return keys</span>
}

func (c *Config) GetLanguageCodes() []string <span class="cov0" title="0">{
        var codes []string
        for code := range SupportedLanguages </span><span class="cov0" title="0">{
                codes = append(codes, code)
        }</span>
        <span class="cov0" title="0">sort.Strings(codes)
        return codes</span>
}

// Legacy support methods
func (c *Config) GetDatabasePath() string <span class="cov0" title="0">{
        return c.Database.Path
}</span>

func (c *Config) GetRPCEndpoint() string <span class="cov0" title="0">{
        if activeNetwork := c.GetActiveNetwork(); activeNetwork != nil </span><span class="cov0" title="0">{
                return activeNetwork.RPCEndpoint
        }</span>
        <span class="cov0" title="0">return "https://eth.drpc.org"</span>
}

func (c *Config) AddCustomNetwork(key string, network Network) <span class="cov0" title="0">{
        if c.CustomNetworks == nil </span><span class="cov0" title="0">{
                c.CustomNetworks = make(map[string]Network)
        }</span>
        <span class="cov0" title="0">network.IsCustom = true
        c.CustomNetworks[key] = network</span>
}

func (c *Config) RemoveCustomNetwork(key string) <span class="cov0" title="0">{
        delete(c.CustomNetworks, key)
}</span>

func (c *Config) GetCustomNetwork(key string) (Network, bool) <span class="cov0" title="0">{
        network, exists := c.CustomNetworks[key]
        return network, exists
}</span>

func (c *Config) GetAllNetworks() map[string]Network <span class="cov0" title="0">{
        allNetworks := make(map[string]Network)
        for k, v := range c.Networks </span><span class="cov0" title="0">{
                allNetworks[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range c.CustomNetworks </span><span class="cov0" title="0">{
                allNetworks[k] = v
        }</span>
        <span class="cov0" title="0">return allNetworks</span>
}

func (c *Config) GetAllNetworkKeys() []string <span class="cov0" title="0">{
        var keys []string

        // Add default networks
        for key := range c.Networks </span><span class="cov0" title="0">{
                keys = append(keys, key)
        }</span>

        // Add custom networks
        <span class="cov0" title="0">for key := range c.CustomNetworks </span><span class="cov0" title="0">{
                keys = append(keys, key)
        }</span>

        <span class="cov0" title="0">sort.Strings(keys)
        return keys</span>
}

func (c *Config) GetNetworkByKey(key string) (Network, bool) <span class="cov0" title="0">{
        // Check default networks first
        if network, exists := c.Networks[key]; exists </span><span class="cov0" title="0">{
                return network, true
        }</span>

        // Check custom networks
        <span class="cov0" title="0">if network, exists := c.CustomNetworks[key]; exists </span><span class="cov0" title="0">{
                return network, true
        }</span>

        <span class="cov0" title="0">return Network{}, false</span>
}

func (c *Config) UpdateNetwork(key string, network Network) error <span class="cov0" title="0">{
        // Check if it's a default network
        if _, exists := c.Networks[key]; exists </span><span class="cov0" title="0">{
                c.Networks[key] = network
                return nil
        }</span>

        // Check if it's a custom network
        <span class="cov0" title="0">if _, exists := c.CustomNetworks[key]; exists </span><span class="cov0" title="0">{
                network.IsCustom = true
                c.CustomNetworks[key] = network
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("network with key %s not found", key)</span>
}

// ToggleNetworkActive toggles the active status of a network without affecting others
func (c *Config) ToggleNetworkActive(networkKey string) error <span class="cov0" title="0">{
        // Check in regular networks
        if network, exists := c.Networks[networkKey]; exists </span><span class="cov0" title="0">{
                network.IsActive = !network.IsActive
                c.Networks[networkKey] = network
                return nil
        }</span>

        // Check in custom networks
        <span class="cov0" title="0">if network, exists := c.CustomNetworks[networkKey]; exists </span><span class="cov0" title="0">{
                network.IsActive = !network.IsActive
                c.CustomNetworks[networkKey] = network
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("network %s not found", networkKey)</span>
}

// GetActiveNetworks returns all active networks
func (c *Config) GetActiveNetworks() map[string]Network <span class="cov0" title="0">{
        activeNetworks := make(map[string]Network)

        // Add active regular networks
        for key, network := range c.Networks </span><span class="cov0" title="0">{
                if network.IsActive </span><span class="cov0" title="0">{
                        activeNetworks[key] = network
                }</span>
        }

        // Add active custom networks
        <span class="cov0" title="0">for key, network := range c.CustomNetworks </span><span class="cov0" title="0">{
                if network.IsActive </span><span class="cov0" title="0">{
                        activeNetworks[key] = network
                }</span>
        }

        <span class="cov0" title="0">return activeNetworks</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package logger

import (
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// Logger defines the interface for logging operations
type Logger interface {
        Info(msg string, fields ...zap.Field)
        Error(msg string, fields ...zap.Field)
        Debug(msg string, fields ...zap.Field)
        Warn(msg string, fields ...zap.Field)
        Sync() error
}

// zapLogger implements the Logger interface using Uber Zap
type zapLogger struct {
        logger *zap.Logger
}

// NewLogger initializes a new logger based on the provided log level
func NewLogger(level string) (Logger, error) <span class="cov0" title="0">{
        var cfg zap.Config

        switch level </span>{
        case "debug":<span class="cov0" title="0">
                cfg = zap.NewDevelopmentConfig()</span>
        case "info":<span class="cov0" title="0">
                cfg = zap.NewProductionConfig()
                cfg.Level = zap.NewAtomicLevelAt(zapcore.InfoLevel)</span>
        case "warn":<span class="cov0" title="0">
                cfg = zap.NewProductionConfig()
                cfg.Level = zap.NewAtomicLevelAt(zapcore.WarnLevel)</span>
        case "error":<span class="cov0" title="0">
                cfg = zap.NewProductionConfig()
                cfg.Level = zap.NewAtomicLevelAt(zapcore.ErrorLevel)</span>
        default:<span class="cov0" title="0">
                cfg = zap.NewProductionConfig()
                cfg.Level = zap.NewAtomicLevelAt(zapcore.InfoLevel)</span>
        }

        <span class="cov0" title="0">logger, err := cfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;zapLogger{logger: logger}, nil</span>
}

// Info logs an informational message
func (z *zapLogger) Info(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        z.logger.Info(msg, fields...)
}</span>

// Error logs an error message
func (z *zapLogger) Error(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        z.logger.Error(msg, fields...)
}</span>

// Debug logs a debug message
func (z *zapLogger) Debug(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        z.logger.Debug(msg, fields...)
}</span>

// Warn logs a warning message
func (z *zapLogger) Warn(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        z.logger.Warn(msg, fields...)
}</span>

// Sync flushes any buffered log entries
func (z *zapLogger) Sync() error <span class="cov0" title="0">{
        return z.logger.Sync()
}</span>

// Helper functions for creating fields
func Error(err error) zap.Field <span class="cov0" title="0">{
        return zap.Error(err)
}</span>

func String(key, val string) zap.Field <span class="cov0" title="0">{
        return zap.String(key, val)
}</span>

func Int(key string, val int) zap.Field <span class="cov0" title="0">{
        return zap.Int(key, val)
}</span>

func Any(key string, val interface{}) zap.Field <span class="cov0" title="0">{
        return zap.Any(key, val)
}</span>

//
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
